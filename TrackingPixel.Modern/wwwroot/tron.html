<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SmartPiXL // TRON</title>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>
<style>
/* ============================================================================
   TRON AESTHETIC — Single-Page App: Operations + Analytics
   Canvas, header, nav, and modal persist across view switches.
   ============================================================================ */
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;900&family=Share+Tech+Mono&display=swap');

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #030810;
  --bg2: #060e1a;
  --panel: rgba(6, 20, 40, 0.85);
  --panel-border: rgba(0, 243, 255, 0.2);
  --panel-glow: rgba(0, 243, 255, 0.05);
  --cyan: #00f3ff;
  --cyan-dim: rgba(0, 243, 255, 0.5);
  --cyan-ghost: rgba(0, 243, 255, 0.08);
  --orange: #ff6a00;
  --orange-dim: rgba(255, 106, 0, 0.5);
  --red: #ff2d55;
  --red-dim: rgba(255, 45, 85, 0.5);
  --green: #00ff88;
  --green-dim: rgba(0, 255, 136, 0.5);
  --yellow: #ffe14d;
  --text: #d4eeff;
  --text-dim: rgba(160, 200, 230, 0.7);
  --mono: 'Share Tech Mono', 'Consolas', monospace;
  --display: 'Orbitron', sans-serif;
}

html { font-size: 16px; }

body {
  font-family: var(--mono);
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  overflow-x: hidden;
  position: relative;
}

/* Scan lines — animated CRT drift */
body::after {
  content: '';
  position: fixed;
  inset: 0;
  background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,243,255,0.025) 2px, rgba(0,243,255,0.025) 4px);
  pointer-events: none;
  z-index: 9999;
  will-change: transform;
  animation: scanDrift 8s linear infinite;
}

@keyframes scanDrift {
  0% { transform: translateY(0); }
  100% { transform: translateY(4px); }
}

/* Grid background */
body::before {
  content: '';
  position: fixed;
  inset: 0;
  background:
    linear-gradient(rgba(0,243,255,0.035) 1px, transparent 1px),
    linear-gradient(90deg, rgba(0,243,255,0.035) 1px, transparent 1px);
  background-size: 60px 60px;
  pointer-events: none;
  z-index: 0;
  will-change: transform;
}

#grid-canvas { position: fixed; inset: 0; z-index: 0; pointer-events: none; }

.vignette {
  position: fixed;
  inset: 0;
  background: radial-gradient(ellipse at center, transparent 40%, rgba(3,8,16,0.5) 65%, rgba(3,8,16,0.85) 100%);
  pointer-events: none;
  z-index: 0;
}

.dashboard {
  position: relative;
  z-index: 1;
  max-width: 1800px;
  margin: 0 auto;
  padding: 16px 24px;
  transition: opacity 0.5s ease, transform 0.5s ease, filter 0.5s ease;
}

.dashboard.hidden {
  opacity: 0;
  transform: translateY(20px) scale(0.98);
  filter: blur(4px);
  pointer-events: none;
}

.dashboard.derezzing {
  animation: dashboardDerezz 0.6s ease-in forwards;
}

@keyframes dashboardDerezz {
  0%   { opacity: 1; transform: translateY(0) scale(1); filter: blur(0); }
  40%  { opacity: 0.7; filter: blur(2px) brightness(1.5); }
  70%  { opacity: 0.3; transform: translateY(10px) scale(0.97); filter: blur(6px) brightness(2); }
  100% { opacity: 0; transform: translateY(30px) scale(0.95); filter: blur(12px) brightness(0); pointer-events: none; }
}

.dashboard.rerezzing {
  animation: dashboardRerezz 0.6s ease-out forwards;
}

@keyframes dashboardRerezz {
  0%   { opacity: 0; transform: translateY(30px) scale(0.95); filter: blur(12px) brightness(0); }
  30%  { opacity: 0.3; filter: blur(6px) brightness(2); }
  60%  { opacity: 0.7; transform: translateY(5px) scale(0.99); filter: blur(2px) brightness(1.5); }
  100% { opacity: 1; transform: translateY(0) scale(1); filter: blur(0) brightness(1); }
}

/* View toggle */
.view-content { display: none; }
.view-content.active { display: block; }

/* ─── LANDING OVERLAY ─── */
.landing-overlay {
  position: fixed;
  inset: 0;
  z-index: 5;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding-top: 6vh;
  gap: 32px;
  transition: opacity 0.4s ease, visibility 0.4s ease;
}

.landing-overlay.hidden {
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
}

.landing-logo {
  font-family: var(--display);
  font-size: 3.5rem;
  font-weight: 900;
  letter-spacing: 14px;
  text-transform: uppercase;
  color: var(--cyan);
  text-shadow: 0 0 40px var(--cyan-dim), 0 0 80px rgba(0,243,255,0.3), 0 0 160px rgba(0,243,255,0.12);
  animation: logoGlow 4s ease-in-out infinite;
  text-align: center;
}

.landing-sub {
  font-family: var(--mono);
  font-size: 0.85rem;
  color: var(--text-dim);
  letter-spacing: 6px;
  text-transform: uppercase;
  text-align: center;
  margin-top: -28px;
}

.landing-buttons {
  display: flex;
  gap: 24px;
}

.landing-btn {
  font-family: var(--display);
  font-size: 0.9rem;
  font-weight: 600;
  letter-spacing: 5px;
  text-transform: uppercase;
  color: var(--cyan);
  background: rgba(0, 243, 255, 0.06);
  border: 1px solid rgba(0, 243, 255, 0.3);
  border-radius: 4px;
  padding: 18px 48px;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
  backdrop-filter: blur(12px) saturate(160%);
  -webkit-backdrop-filter: blur(12px) saturate(160%);
}

.landing-btn::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--cyan), transparent);
  opacity: 0.6;
  transition: opacity 0.3s;
}

.landing-btn::after {
  content: '';
  position: absolute;
  bottom: 0; left: 0; right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--cyan), transparent);
  transform: scaleX(0);
  transition: transform 0.4s ease;
}

.landing-btn:hover {
  color: #fff;
  background: rgba(0, 243, 255, 0.15);
  border-color: var(--cyan);
  box-shadow: 0 0 30px rgba(0,243,255,0.15), 0 0 60px rgba(0,243,255,0.08), inset 0 0 30px rgba(0,243,255,0.06);
  transform: translateY(-2px);
}

.landing-btn:hover::before { opacity: 1; }
.landing-btn:hover::after { transform: scaleX(1); }

.landing-btn:active {
  transform: translateY(0);
  box-shadow: 0 0 50px rgba(0,243,255,0.25), 0 0 100px rgba(0,243,255,0.1), inset 0 0 50px rgba(0,243,255,0.1);
}

.landing-hint {
  font-family: var(--mono);
  font-size: 0.7rem;
  color: var(--text-dim);
  letter-spacing: 3px;
  opacity: 0.4;
  text-align: center;
  animation: hintPulse 4s ease-in-out infinite;
}

@keyframes hintPulse {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.6; }
}

/* ─── HEADER ─── */
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 0 20px;
  border-bottom: 1px solid var(--panel-border);
  margin-bottom: 24px;
}

.header-left { display: flex; align-items: center; gap: 16px; }

.logo {
  font-family: var(--display);
  font-size: 1.6rem;
  font-weight: 900;
  letter-spacing: 6px;
  text-transform: uppercase;
  color: var(--cyan);
  text-shadow: 0 0 20px var(--cyan-dim), 0 0 60px rgba(0,243,255,0.3), 0 0 120px rgba(0,243,255,0.1);
  animation: logoGlow 4s ease-in-out infinite;
}

@keyframes logoGlow {
  0%, 100% { text-shadow: 0 0 20px var(--cyan-dim), 0 0 60px rgba(0,243,255,0.3), 0 0 120px rgba(0,243,255,0.1); }
  50% { text-shadow: 0 0 40px var(--cyan), 0 0 80px rgba(0,243,255,0.5), 0 0 150px rgba(0,243,255,0.2), 0 0 250px rgba(0,243,255,0.06); }
}

.logo-sub {
  font-family: var(--mono);
  font-size: 0.78rem;
  color: var(--text-dim);
  letter-spacing: 3px;
  text-transform: uppercase;
}

.status-beacon {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.82rem;
  font-weight: 500;
  letter-spacing: 2px;
  text-transform: uppercase;
}

.beacon-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: var(--green);
  box-shadow: 0 0 10px var(--green), 0 0 25px var(--green-dim), 0 0 50px rgba(0,255,136,0.15);
  animation: pulse 2s ease-in-out infinite;
}

.beacon-dot.warn { background: var(--yellow); box-shadow: 0 0 10px var(--yellow), 0 0 25px rgba(255,225,77,0.4), 0 0 50px rgba(255,225,77,0.15); }
.beacon-dot.danger { background: var(--red); box-shadow: 0 0 10px var(--red), 0 0 25px var(--red-dim), 0 0 50px rgba(255,45,85,0.15); animation: pulse 0.8s ease-in-out infinite; }

@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.4; transform: scale(0.8); }
}

.header-right {
  display: flex;
  align-items: center;
  gap: 20px;
  font-size: 0.78rem;
  color: var(--text-dim);
}

.refresh-timer { font-family: var(--mono); color: var(--cyan-dim); }

/* ─── NAV ─── */
.nav-bar {
  display: flex;
  gap: 2px;
  margin-bottom: 24px;
}

.nav-tab {
  font-family: var(--display);
  font-size: 0.72rem;
  font-weight: 500;
  letter-spacing: 3px;
  text-transform: uppercase;
  padding: 10px 24px;
  background: var(--panel);
  border: 1px solid var(--panel-border);
  color: var(--text-dim);
  text-decoration: none;
  transition: all 0.2s;
  cursor: pointer;
  user-select: none;
}

.nav-tab:first-child { border-radius: 4px 0 0 4px; }
.nav-tab:last-child { border-radius: 0 4px 4px 0; }

.nav-tab:hover {
  color: var(--cyan);
  border-color: var(--cyan-dim);
  background: rgba(0,243,255,0.05);
}

.nav-tab.active {
  color: var(--cyan);
  border-color: var(--cyan);
  background: rgba(0,243,255,0.1);
  box-shadow: 0 0 20px rgba(0,243,255,0.1), 0 0 40px rgba(0,243,255,0.05), inset 0 0 20px rgba(0,243,255,0.03);
}

/* ─── PANELS ─── */
.panel-grid {
  display: grid;
  grid-template-columns: 2fr 1fr;
  gap: 20px;
  margin-bottom: 24px;
}

.panel-grid.triple { grid-template-columns: 1fr 1fr 1fr; }
.panel-grid.half { grid-template-columns: 1fr 1fr; }

.panel {
  background: var(--panel);
  border: 1px solid var(--panel-border);
  border-radius: 4px;
  padding: 20px;
  position: relative;
  overflow: hidden;
  transition: border-color 0.3s, box-shadow 0.3s;
  contain: layout style paint;
  backdrop-filter: blur(16px) saturate(180%);
  -webkit-backdrop-filter: blur(16px) saturate(180%);
}

.panel::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--cyan-dim), transparent);
  opacity: 0.6;
  transition: opacity 0.3s;
}

.panel:hover {
  border-color: rgba(0,243,255,0.45);
  box-shadow: 0 0 30px rgba(0,243,255,0.12), 0 0 60px rgba(0,243,255,0.04), inset 0 0 30px rgba(0,243,255,0.03);
}

.panel:hover::before { opacity: 1; }

.panel-title {
  font-family: var(--display);
  font-size: 0.8rem;
  font-weight: 600;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: var(--cyan);
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.panel-title::before { content: '//'; color: var(--text-dim); }

/* ─── PIPELINE (shared) ─── */
.pipeline {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0;
  padding: 12px 0;
}

.pipe-node {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  padding: 12px 16px;
  background: var(--panel);
  border: 1px solid var(--panel-border);
  border-radius: 4px;
  min-width: 110px;
  transition: all 0.3s;
  cursor: pointer;
}

.pipe-node:hover {
  border-color: rgba(0,243,255,0.5);
  box-shadow: 0 0 25px rgba(0,243,255,0.1);
}

.pipe-node.healthy { border-color: rgba(0,255,136,0.3); animation: nodeBreath 3s ease-in-out infinite; }
.pipe-node.healthy:hover { box-shadow: 0 0 25px rgba(0,255,136,0.15); }

@keyframes nodeBreath {
  0%, 100% { box-shadow: 0 0 10px rgba(0,255,136,0.05); }
  50% { box-shadow: 0 0 25px rgba(0,255,136,0.15), inset 0 0 15px rgba(0,255,136,0.04); }
}
.pipe-node.stale { border-color: rgba(255,225,77,0.3); background: rgba(255,225,77,0.03); }
.pipe-node.down { border-color: rgba(255,45,85,0.3); background: rgba(255,45,85,0.03); }

.pipe-node-label {
  font-family: var(--display);
  font-size: 0.6rem;
  font-weight: 500;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--cyan);
}

.pipe-node-value { font-family: var(--display); font-size: 0.9rem; font-weight: 700; }
.pipe-node-sub { font-size: 0.65rem; color: var(--text-dim); }

.pipe-arrow {
  width: 30px;
  height: 3px;
  background: linear-gradient(90deg, var(--cyan-dim), var(--cyan));
  position: relative;
  animation: dataFlow 2s linear infinite;
  box-shadow: 0 0 8px var(--cyan-dim), 0 0 16px rgba(0,243,255,0.1);
  border-radius: 1px;
}

.pipe-arrow.dead {
  background: linear-gradient(90deg, var(--red-dim), var(--red));
  animation: none;
  opacity: 0.4;
}

.pipe-arrow::after {
  content: '';
  position: absolute;
  right: -5px; top: -4px;
  width: 0; height: 0;
  border-left: 7px solid var(--cyan);
  border-top: 5px solid transparent;
  border-bottom: 5px solid transparent;
}

.pipe-arrow.dead::after { border-left-color: var(--red); }

.pipe-arrow::before {
  content: '';
  position: absolute;
  width: 6px;
  height: 6px;
  top: -2px;
  border-radius: 50%;
  background: var(--cyan);
  box-shadow: 0 0 8px var(--cyan), 0 0 16px var(--cyan-dim);
  animation: arrowParticle 2s linear infinite;
}

.pipe-arrow.dead::before { display: none; }

@keyframes arrowParticle {
  0% { left: -6px; opacity: 0; }
  10% { opacity: 1; }
  90% { opacity: 1; }
  100% { left: 100%; opacity: 0; }
}

@keyframes dataFlow {
  0% { opacity: 0.3; }
  50% { opacity: 1; }
  100% { opacity: 0.3; }
}

/* ─── FEED TABLE (shared) ─── */
.feed-table { width: 100%; border-collapse: collapse; font-size: 0.82rem; }

.feed-table th {
  font-family: var(--display);
  font-size: 0.7rem;
  font-weight: 600;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--cyan-dim);
  text-align: left;
  padding: 8px 10px;
  border-bottom: 1px solid var(--panel-border);
}

.feed-table td {
  padding: 6px 10px;
  border-bottom: 1px solid rgba(0,243,255,0.05);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 180px;
}

.feed-table tr { transition: background 0.2s, box-shadow 0.2s; cursor: pointer; }
.feed-table tr:hover { background: rgba(0,243,255,0.08); box-shadow: inset 0 0 20px rgba(0,243,255,0.04); }

@keyframes rowFlash {
  0% { background: rgba(0,243,255,0.15); }
  100% { background: transparent; }
}

/* ─── BADGE (shared) ─── */
.badge {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 2px;
  font-family: var(--display);
  font-size: 0.7rem;
  font-weight: 700;
  letter-spacing: 1px;
}

.badge.high { background: rgba(255,45,85,0.2); color: var(--red); border: 1px solid rgba(255,45,85,0.3); }
.badge.med { background: rgba(255,106,0,0.2); color: var(--orange); border: 1px solid rgba(255,106,0,0.3); }
.badge.low { background: rgba(255,225,77,0.15); color: var(--yellow); border: 1px solid rgba(255,225,77,0.2); }
.badge.ok { background: rgba(0,255,136,0.1); color: var(--green); border: 1px solid rgba(0,255,136,0.2); }

/* ─── LOADING (shared) ─── */
.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 40px;
  color: var(--text-dim);
  font-size: 0.78rem;
  letter-spacing: 3px;
}

.loading::after {
  content: '';
  width: 20px; height: 20px;
  border: 2px solid var(--panel-border);
  border-top-color: var(--cyan);
  border-right-color: var(--cyan-dim);
  border-radius: 50%;
  margin-left: 12px;
  animation: spin 0.8s linear infinite;
  box-shadow: 0 0 12px rgba(0,243,255,0.2);
}

@keyframes spin { to { transform: rotate(360deg); } }

/* ─── MODAL (shared) ─── */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(3, 8, 16, 0.88);
  backdrop-filter: blur(6px);
  z-index: 10000;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s;
}

.modal-overlay.active { opacity: 1; pointer-events: all; }

.modal-panel {
  background: var(--bg2);
  border: 1px solid var(--cyan-dim);
  border-radius: 6px;
  padding: 28px;
  max-width: 800px;
  width: 92%;
  max-height: 82vh;
  overflow-y: auto;
  position: relative;
  box-shadow: 0 0 60px rgba(0,243,255,0.15), 0 0 120px rgba(0,243,255,0.08), 0 0 200px rgba(0,243,255,0.03);
  transform: scale(0.95);
  transition: transform 0.3s;
  backdrop-filter: blur(20px) saturate(200%);
  -webkit-backdrop-filter: blur(20px) saturate(200%);
}

.modal-overlay.active .modal-panel { transform: scale(1); }

.modal-panel::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--cyan), transparent);
}

.modal-close {
  position: absolute;
  top: 12px; right: 12px;
  background: none;
  border: 1px solid var(--panel-border);
  color: var(--text-dim);
  width: 32px;
  height: 32px;
  cursor: pointer;
  font-size: 1.1rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 3px;
  transition: all 0.2s;
  font-family: var(--mono);
}

.modal-close:hover {
  color: var(--cyan);
  border-color: var(--cyan-dim);
  box-shadow: 0 0 12px rgba(0,243,255,0.1);
}

.modal-title {
  font-family: var(--display);
  font-size: 0.85rem;
  font-weight: 600;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: var(--cyan);
  margin-bottom: 20px;
  padding-right: 40px;
}

.modal-title::before { content: '// '; color: var(--text-dim); }

.modal-body { font-size: 0.82rem; line-height: 1.6; }

.modal-body .detail-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-top: 12px;
}

.modal-body .detail-item {
  padding: 10px 14px;
  background: rgba(0,243,255,0.03);
  border: 1px solid rgba(0,243,255,0.08);
  border-radius: 4px;
}

.modal-body .detail-label {
  font-family: var(--display);
  font-size: 0.65rem;
  font-weight: 500;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--text-dim);
  margin-bottom: 4px;
}

.modal-body .detail-value {
  font-family: var(--mono);
  font-size: 0.88rem;
  color: var(--text);
}

.modal-body .detail-value.ok { color: var(--green); }
.modal-body .detail-value.bad { color: var(--red); }
.modal-body .detail-value.warn { color: var(--yellow); }
.modal-body .detail-value.cyan { color: var(--cyan); }

.modal-body .full-text {
  background: rgba(0,0,0,0.3);
  border: 1px solid var(--panel-border);
  border-radius: 4px;
  padding: 14px;
  margin-top: 12px;
  white-space: pre-wrap;
  word-break: break-word;
  font-size: 0.8rem;
  line-height: 1.5;
  max-height: 300px;
  overflow-y: auto;
}

.modal-body .suggestion {
  margin-top: 16px;
  padding: 12px 16px;
  background: rgba(0,243,255,0.04);
  border: 1px solid rgba(0,243,255,0.15);
  border-radius: 4px;
  font-size: 0.78rem;
  line-height: 1.5;
  color: var(--text);
}

.modal-body .suggestion-title {
  font-family: var(--display);
  font-size: 0.7rem;
  font-weight: 600;
  letter-spacing: 2px;
  color: var(--cyan);
  margin-bottom: 8px;
}

/* ============================================================================
   OPERATIONS VIEW — Critical Zone, Status Strip, Infra, Error Log, ETL
   ============================================================================ */

/* Critical Issues Zone */
#critical-zone { margin-bottom: 24px; }
#critical-zone.slide-in { animation: criticalSlideIn 0.4s ease-out; }

@keyframes criticalSlideIn {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}

.critical-panel {
  background: rgba(255, 45, 85, 0.04);
  border: 1px solid rgba(255, 45, 85, 0.4);
  border-radius: 4px;
  padding: 20px;
  position: relative;
  overflow: hidden;
  animation: criticalBreath 2s ease-in-out infinite;
}

@keyframes criticalBreath {
  0%, 100% { box-shadow: 0 0 20px rgba(255,45,85,0.08), inset 0 0 20px rgba(255,45,85,0.02); }
  50% { box-shadow: 0 0 40px rgba(255,45,85,0.2), 0 0 80px rgba(255,45,85,0.06), inset 0 0 40px rgba(255,45,85,0.04); }
}

.critical-panel::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--red), var(--orange), var(--red), transparent);
  animation: criticalGlow 2s ease-in-out infinite;
}

@keyframes criticalGlow {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}

.critical-header { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; }

.critical-icon {
  width: 22px; height: 22px; border-radius: 50%;
  background: var(--red);
  box-shadow: 0 0 14px var(--red-dim), 0 0 35px rgba(255,45,85,0.25);
  animation: pulse 0.8s ease-in-out infinite;
  flex-shrink: 0;
}

.critical-icon.warning {
  background: var(--yellow);
  box-shadow: 0 0 14px rgba(255,225,77,0.5), 0 0 35px rgba(255,225,77,0.2);
  animation: pulse 2s ease-in-out infinite;
}

.critical-title {
  font-family: var(--display);
  font-size: 0.82rem;
  font-weight: 600;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: var(--red);
}

.critical-title.warning { color: var(--yellow); }

.critical-count {
  margin-left: auto;
  font-family: var(--display);
  font-size: 0.72rem;
  font-weight: 500;
  letter-spacing: 2px;
  color: var(--text-dim);
}

.critical-issue {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 10px 14px;
  margin-bottom: 4px;
  border-radius: 4px;
  border-left: 3px solid var(--red);
  background: rgba(255, 45, 85, 0.06);
  transition: background 0.2s;
  cursor: pointer;
}

.critical-issue:hover { background: rgba(255, 45, 85, 0.12); }
.critical-issue.warning { border-left-color: var(--yellow); background: rgba(255, 225, 77, 0.04); }
.critical-issue.warning:hover { background: rgba(255, 225, 77, 0.1); }

.issue-severity {
  font-family: var(--display);
  font-size: 0.65rem;
  font-weight: 600;
  letter-spacing: 1px;
  padding: 2px 8px;
  border-radius: 2px;
  flex-shrink: 0;
  margin-top: 1px;
}

.issue-severity.critical { background: rgba(255,45,85,0.2); color: var(--red); border: 1px solid rgba(255,45,85,0.3); }
.issue-severity.warning { background: rgba(255,225,77,0.15); color: var(--yellow); border: 1px solid rgba(255,225,77,0.2); }

.issue-body { flex: 1; min-width: 0; }
.issue-title { font-size: 0.88rem; font-weight: bold; color: var(--text); margin-bottom: 3px; }
.issue-detail { font-size: 0.78rem; color: var(--text-dim); line-height: 1.5; }
.issue-time { font-size: 0.7rem; color: var(--text-dim); flex-shrink: 0; text-align: right; }

/* Status Strip */
.status-strip { display: flex; gap: 3px; margin-bottom: 24px; flex-wrap: wrap; }

.status-chip {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 16px;
  background: var(--panel);
  border: 1px solid var(--panel-border);
  border-radius: 4px;
  flex: 1;
  min-width: 140px;
  transition: all 0.3s;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  backdrop-filter: blur(12px) saturate(160%);
  -webkit-backdrop-filter: blur(12px) saturate(160%);
}

.status-chip::after {
  content: '';
  position: absolute;
  bottom: 0; left: 0; right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--cyan), transparent);
  transform: scaleX(0);
  transition: transform 0.4s ease;
  pointer-events: none;
}

.status-chip:hover::after { transform: scaleX(1); }
.status-chip.healthy::after { background: linear-gradient(90deg, transparent, var(--green), transparent); transform: scaleX(1); opacity: 0.5; }
.status-chip.degraded::after { background: linear-gradient(90deg, transparent, var(--yellow), transparent); transform: scaleX(1); opacity: 0.5; }
.status-chip.critical::after { background: linear-gradient(90deg, transparent, var(--red), transparent); transform: scaleX(1); opacity: 0.5; animation: chipPulse 1.5s ease-in-out infinite; }

@keyframes chipPulse {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.8; }
}

.status-chip:hover { border-color: rgba(0,243,255,0.4); box-shadow: 0 0 20px rgba(0,243,255,0.08); }
.status-chip.healthy { border-color: rgba(0,255,136,0.3); }
.status-chip.healthy:hover { border-color: rgba(0,255,136,0.5); box-shadow: 0 0 20px rgba(0,255,136,0.1); }
.status-chip.degraded { border-color: rgba(255,225,77,0.3); background: rgba(255,225,77,0.03); }
.status-chip.degraded:hover { border-color: rgba(255,225,77,0.5); box-shadow: 0 0 20px rgba(255,225,77,0.1); }
.status-chip.critical { border-color: rgba(255,45,85,0.3); background: rgba(255,45,85,0.03); }
.status-chip.critical:hover { border-color: rgba(255,45,85,0.5); box-shadow: 0 0 20px rgba(255,45,85,0.1); }

.chip-dot { width: 9px; height: 9px; border-radius: 50%; flex-shrink: 0; }
.chip-dot.up { background: var(--green); box-shadow: 0 0 8px var(--green-dim); }
.chip-dot.down { background: var(--red); box-shadow: 0 0 8px var(--red-dim); animation: pulse 0.8s ease-in-out infinite; }
.chip-dot.warn { background: var(--yellow); box-shadow: 0 0 8px rgba(255,225,77,0.4); }
.chip-dot.idle { background: var(--text-dim); }

.chip-label {
  font-family: var(--display);
  font-size: 0.65rem;
  font-weight: 500;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--text-dim);
}

.chip-value { margin-left: auto; font-family: var(--mono); font-size: 0.78rem; color: var(--text); }
.chip-value.ok { color: var(--green); }
.chip-value.bad { color: var(--red); }
.chip-value.warn { color: var(--yellow); }

/* Error Log */
.error-log { font-size: 0.82rem; }

.error-entry {
  display: flex;
  align-items: flex-start;
  gap: 10px;
  padding: 8px 12px;
  margin-bottom: 3px;
  border-radius: 3px;
  border-left: 2px solid rgba(255,45,85,0.4);
  background: rgba(255,45,85,0.04);
  transition: background 0.2s;
  cursor: pointer;
}

.error-entry:hover { background: rgba(255,45,85,0.1); }
.error-entry.stale { border-left-color: rgba(255,225,77,0.3); background: rgba(255,225,77,0.02); opacity: 0.6; }

.error-source {
  font-family: var(--display);
  font-size: 0.65rem;
  font-weight: 500;
  letter-spacing: 1px;
  color: var(--text-dim);
  width: 80px;
  flex-shrink: 0;
  text-transform: uppercase;
}

.error-msg { flex: 1; color: var(--text); word-break: break-word; }
.error-msg.stale { color: var(--text-dim); }

.error-count { font-family: var(--display); font-size: 0.7rem; font-weight: 600; color: var(--red); flex-shrink: 0; }
.error-age { font-size: 0.7rem; color: var(--text-dim); flex-shrink: 0; width: 60px; text-align: right; }

/* ETL Grid */
.etl-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }

.etl-stat {
  text-align: center;
  padding: 12px 8px;
  background: rgba(0,243,255,0.03);
  border: 1px solid rgba(0,243,255,0.08);
  border-radius: 4px;
}

.etl-val { font-family: var(--display); font-size: 1.1rem; font-weight: 700; color: var(--cyan); text-shadow: 0 0 10px rgba(0,243,255,0.2); }
.etl-val.warn { color: var(--yellow); text-shadow: 0 0 10px rgba(255,225,77,0.2); }
.etl-val.bad { color: var(--red); text-shadow: 0 0 10px rgba(255,45,85,0.2); }
.etl-lbl { font-size: 0.65rem; font-weight: 500; color: var(--text-dim); letter-spacing: 1px; text-transform: uppercase; margin-top: 4px; }

/* Infra Grid */
.infra-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }

.infra-group-title {
  font-family: var(--display);
  font-size: 0.7rem;
  font-weight: 600;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: var(--cyan-dim);
  margin-bottom: 10px;
  padding-bottom: 6px;
  border-bottom: 1px solid var(--panel-border);
}

.infra-item { display: flex; align-items: center; gap: 10px; padding: 6px 0; font-size: 0.82rem; }

.infra-dot { width: 9px; height: 9px; border-radius: 50%; flex-shrink: 0; }
.infra-dot.up { background: var(--green); box-shadow: 0 0 6px var(--green-dim); }
.infra-dot.down { background: var(--red); box-shadow: 0 0 6px var(--red-dim); }
.infra-dot.warn { background: var(--yellow); box-shadow: 0 0 6px rgba(255,225,77,0.3); }

.infra-item-name { flex: 1; }
.infra-item-detail { font-size: 0.72rem; color: var(--text-dim); text-align: right; }
.infra-item-ms { font-family: var(--display); font-size: 0.72rem; font-weight: 500; color: var(--cyan-dim); width: 50px; text-align: right; }

.infra-app-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 8px; }

.infra-app-stat {
  text-align: center;
  padding: 8px 4px;
  background: rgba(0,243,255,0.03);
  border: 1px solid rgba(0,243,255,0.06);
  border-radius: 3px;
}

.infra-app-val { font-family: var(--display); font-size: 0.9rem; font-weight: 700; color: var(--cyan); }
.infra-app-lbl { font-size: 0.65rem; font-weight: 500; color: var(--text-dim); letter-spacing: 1px; text-transform: uppercase; margin-top: 2px; }

/* All-Clear Banner */
.all-clear {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px 22px;
  background: rgba(0,255,136,0.04);
  border: 1px solid rgba(0,255,136,0.2);
  border-radius: 4px;
  box-shadow: 0 0 30px rgba(0,255,136,0.04);
  animation: allClearPulse 4s ease-in-out infinite;
}

@keyframes allClearPulse {
  0%, 100% { box-shadow: 0 0 30px rgba(0,255,136,0.06); }
  50% { box-shadow: 0 0 60px rgba(0,255,136,0.15), 0 0 100px rgba(0,255,136,0.06), 0 0 160px rgba(0,255,136,0.02); }
}

.all-clear-dot {
  width: 14px; height: 14px; border-radius: 50%;
  background: var(--green);
  box-shadow: 0 0 12px var(--green-dim), 0 0 30px rgba(0,255,136,0.2);
  animation: pulse 3s ease-in-out infinite;
}

.all-clear-text {
  font-family: var(--display);
  font-size: 0.82rem;
  font-weight: 600;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: var(--green);
  text-shadow: 0 0 15px rgba(0,255,136,0.3);
}

.all-clear-sub { margin-left: auto; font-size: 0.72rem; color: var(--text-dim); }

/* ============================================================================
   ANALYTICS VIEW — Hero Cards, Charts, Signals, Evasion, Behavior, FP, Devices
   ============================================================================ */

/* Hero Cards */
.hero-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 16px; margin-bottom: 24px; }

.hero-card {
  background: var(--panel);
  border: 1px solid var(--panel-border);
  border-radius: 4px;
  padding: 16px 20px;
  position: relative;
  overflow: hidden;
  transition: border-color 0.3s, box-shadow 0.3s;
  cursor: pointer;
}

.hero-card::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--cyan), transparent);
  opacity: 0.6;
  transition: opacity 0.3s;
}

.hero-card:hover { border-color: var(--cyan-dim); box-shadow: 0 0 40px rgba(0,243,255,0.1), 0 0 80px rgba(0,243,255,0.04), inset 0 0 40px rgba(0,243,255,0.04); }
.hero-card:hover::before { opacity: 1; }

.hero-card::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(105deg, transparent 40%, rgba(0,243,255,0.04) 45%, rgba(0,243,255,0.08) 50%, rgba(0,243,255,0.04) 55%, transparent 60%);
  animation: holoSweep 5s ease-in-out infinite;
  pointer-events: none;
}

@keyframes holoSweep {
  0% { transform: translateX(-100%); }
  50%, 100% { transform: translateX(200%); }
}

.hero-label {
  font-family: var(--display);
  font-size: 0.65rem;
  font-weight: 500;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: var(--text-dim);
  margin-bottom: 8px;
}

.hero-value {
  font-family: var(--display);
  font-size: 2rem;
  font-weight: 700;
  color: var(--cyan);
  text-shadow: 0 0 20px var(--cyan-dim);
  line-height: 1;
  animation: valueBreath 4s ease-in-out infinite;
}

@keyframes valueBreath {
  0%, 100% { text-shadow: 0 0 20px var(--cyan-dim); filter: brightness(1); }
  50% { text-shadow: 0 0 35px var(--cyan), 0 0 70px var(--cyan-dim), 0 0 120px rgba(0,243,255,0.1); filter: brightness(1.15); }
}

.hero-value.warn { color: var(--yellow); text-shadow: 0 0 20px rgba(255,225,77,0.3); }
.hero-value.danger { color: var(--red); text-shadow: 0 0 20px var(--red-dim); }
.hero-value.good { color: var(--green); text-shadow: 0 0 20px var(--green-dim); }

.hero-sub { font-size: 0.72rem; color: var(--text-dim); margin-top: 6px; }

/* Hourly Chart */
.chart-container { height: 200px; display: flex; align-items: flex-end; gap: 2px; padding-top: 10px; }

.chart-bar-group { flex: 1; display: flex; flex-direction: column; align-items: center; gap: 2px; min-width: 0; cursor: pointer; transition: opacity 0.2s; }
.chart-bar-group:hover { opacity: 0.8; }

.chart-bar { width: 100%; min-height: 1px; border-radius: 1px 1px 0 0; transition: height 0.6s ease; }
.chart-bar.human { background: linear-gradient(to top, rgba(0,243,255,0.3), rgba(0,243,255,0.7)); box-shadow: 0 0 8px rgba(0,243,255,0.3); }
.chart-bar.bot { background: linear-gradient(to top, rgba(255,45,85,0.3), rgba(255,45,85,0.7)); box-shadow: 0 0 8px rgba(255,45,85,0.3); }

.chart-label { font-size: 0.6rem; color: var(--text-dim); writing-mode: vertical-rl; transform: rotate(180deg); max-height: 50px; overflow: hidden; }

/* Risk Gauge */
.risk-list { display: flex; flex-direction: column; gap: 12px; }

.risk-row {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 12px;
  border-radius: 4px;
  border: 1px solid transparent;
  transition: all 0.2s;
  cursor: pointer;
}

.risk-row:hover { border-color: var(--panel-border); background: var(--cyan-ghost); }

.risk-indicator { width: 6px; height: 32px; border-radius: 3px; flex-shrink: 0; }
.risk-indicator.high { background: var(--red); box-shadow: 0 0 10px var(--red-dim); }
.risk-indicator.medium { background: var(--orange); box-shadow: 0 0 10px var(--orange-dim); }
.risk-indicator.low { background: var(--yellow); box-shadow: 0 0 8px rgba(255,225,77,0.3); }
.risk-indicator.ok { background: var(--green); box-shadow: 0 0 8px var(--green-dim); }

.risk-info { flex: 1; }
.risk-label { font-size: 0.82rem; letter-spacing: 1px; }
.risk-count { font-family: var(--display); font-size: 1.3rem; font-weight: 700; text-shadow: 0 0 10px rgba(0,243,255,0.15); }
.risk-meta { font-size: 0.72rem; color: var(--text-dim); }

/* Signal Bars */
.signal-list { display: flex; flex-direction: column; gap: 8px; }
.signal-row { display: flex; align-items: center; gap: 10px; cursor: pointer; }
.signal-row:hover .signal-bar-fill { box-shadow: 0 0 16px var(--cyan-dim); }

.signal-name { width: 180px; flex-shrink: 0; font-size: 0.78rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

.signal-bar-track { flex: 1; height: 16px; background: rgba(0,243,255,0.05); border-radius: 2px; overflow: hidden; }

.signal-bar-fill {
  height: 100%;
  border-radius: 2px;
  background: linear-gradient(90deg, var(--cyan-dim), var(--cyan));
  box-shadow: 0 0 10px var(--cyan-dim);
  transition: width 0.8s ease, box-shadow 0.3s;
  position: relative;
}

.signal-bar-fill::after {
  content: '';
  position: absolute;
  right: 0; top: 0; bottom: 0;
  width: 2px;
  background: var(--cyan);
  box-shadow: 0 0 8px var(--cyan);
}

.signal-count { width: 50px; text-align: right; font-size: 0.78rem; color: var(--cyan); }

/* Evasion Grid */
.evasion-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }

.evasion-card {
  text-align: center;
  padding: 12px;
  background: rgba(0,243,255,0.03);
  border: 1px solid rgba(0,243,255,0.08);
  border-radius: 4px;
  transition: border-color 0.3s, box-shadow 0.3s;
  cursor: pointer;
}

.evasion-card:hover { border-color: rgba(0,243,255,0.2); box-shadow: 0 0 15px rgba(0,243,255,0.05); }

.evasion-val { font-family: var(--display); font-size: 1.4rem; font-weight: 700; color: var(--cyan); text-shadow: 0 0 10px rgba(0,243,255,0.2); }
.evasion-val.alert { color: var(--red); text-shadow: 0 0 12px var(--red-dim); }
.evasion-lbl { font-size: 0.65rem; font-weight: 500; color: var(--text-dim); letter-spacing: 1px; text-transform: uppercase; margin-top: 4px; }

/* Behavior */
.behavior-compare { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
.behavior-col { text-align: center; }
.behavior-col-title {
  font-family: var(--display);
  font-size: 0.72rem;
  font-weight: 600;
  letter-spacing: 3px;
  text-transform: uppercase;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--panel-border);
}

.behavior-col-title.human { color: var(--cyan); }
.behavior-col-title.bot { color: var(--red); }
.behavior-stat { display: flex; justify-content: space-between; padding: 5px 8px; font-size: 0.78rem; }
.behavior-stat .val { font-weight: bold; }

/* Fingerprint Clusters */
.fp-cluster-list { display: flex; flex-direction: column; gap: 6px; }

.fp-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 7px 10px;
  border-radius: 3px;
  border: 1px solid transparent;
  transition: all 0.2s;
  font-size: 0.78rem;
  cursor: pointer;
}

.fp-row:hover { border-color: var(--panel-border); background: var(--cyan-ghost); }

.fp-hash { font-family: var(--mono); color: var(--cyan); width: 100px; flex-shrink: 0; }
.fp-meta { flex: 1; color: var(--text-dim); }
.fp-hits { font-family: var(--display); font-weight: 700; color: var(--text); }

/* ─── RESPONSIVE ─── */
@media (max-width: 1400px) {
  .hero-grid { grid-template-columns: repeat(3, 1fr); }
}

@media (max-width: 1200px) {
  .status-strip { flex-wrap: wrap; }
  .status-chip { min-width: 120px; }
}

@media (max-width: 900px) {
  .hero-grid { grid-template-columns: repeat(2, 1fr); }
  .panel-grid, .panel-grid.triple, .panel-grid.half { grid-template-columns: 1fr; }
  .infra-grid { grid-template-columns: 1fr; }
  .infra-app-grid { grid-template-columns: repeat(2, 1fr); }
  .etl-grid { grid-template-columns: repeat(2, 1fr); }
  .evasion-grid { grid-template-columns: repeat(2, 1fr); }
  .pipeline { flex-wrap: wrap; gap: 8px; }
  .pipe-arrow { display: none; }
  .status-strip { gap: 8px; }
  .modal-body .detail-grid { grid-template-columns: 1fr; }
}

::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--panel-border); border-radius: 4px; box-shadow: 0 0 6px rgba(0,243,255,0.1); }
::-webkit-scrollbar-thumb:hover { background: var(--cyan-dim); box-shadow: 0 0 12px rgba(0,243,255,0.25); }
</style>
</head>
<body>

<canvas id="grid-canvas"></canvas>
<div class="vignette"></div>

<!-- LANDING OVERLAY — visible on load, hides when a view activates -->
<div class="landing-overlay" id="landing-overlay">
  <div class="landing-logo">SMARTPIXL</div>
  <div class="landing-sub">DevOps Command Center</div>
  <div class="landing-buttons">
    <button class="landing-btn" onclick="enterView('ops')">OPERATIONS</button>
    <button class="landing-btn" onclick="enterView('analytics')">ANALYTICS</button>
  </div>
  <div class="landing-hint">SELECT A VIEW TO ENTER THE GRID</div>
</div>

<div class="dashboard hidden" id="dashboard">
  <!-- ══════════════════════════════════════════════════════════════════════
       SHARED HEADER (persists across views)
       ══════════════════════════════════════════════════════════════════════ -->
  <div class="header">
    <div class="header-left">
      <div>
        <div class="logo">SMARTPIXL</div>
        <div class="logo-sub" id="logo-sub">Operations Center</div>
      </div>
      <div class="status-beacon">
        <div class="beacon-dot" id="beacon"></div>
        <span id="system-status">CONNECTING...</span>
      </div>
    </div>
    <div class="header-right">
      <div>UTC <span id="utc-clock">--:--:--</span></div>
      <div>REFRESH <span class="refresh-timer" id="countdown">10</span>s</div>
      <div id="etl-header-wrap">ETL <span id="etl-status">--</span></div>
    </div>
  </div>

  <!-- SHARED NAV (JS-driven, no page reload) -->
  <div class="nav-bar">
    <a class="nav-tab" id="nav-ops" onclick="toggleView('ops')">OPERATIONS</a>
    <a class="nav-tab" id="nav-analytics" onclick="toggleView('analytics')">ANALYTICS</a>
  </div>

  <!-- ══════════════════════════════════════════════════════════════════════
       OPERATIONS VIEW
       ══════════════════════════════════════════════════════════════════════ -->
  <div id="view-ops" class="view-content">
    <!-- Critical Issues -->
    <div id="critical-zone"></div>

    <!-- Status Strip -->
    <div class="status-strip" id="status-strip">
      <div class="status-chip"><div class="chip-dot idle"></div><div class="chip-label">OVERALL</div><div class="chip-value">--</div></div>
      <div class="status-chip"><div class="chip-dot idle"></div><div class="chip-label">DATA FLOW</div><div class="chip-value">--</div></div>
      <div class="status-chip"><div class="chip-dot idle"></div><div class="chip-label">SQL</div><div class="chip-value">--</div></div>
      <div class="status-chip"><div class="chip-dot idle"></div><div class="chip-label">IIS</div><div class="chip-value">--</div></div>
      <div class="status-chip"><div class="chip-dot idle"></div><div class="chip-label">ETL</div><div class="chip-value">--</div></div>
      <div class="status-chip"><div class="chip-dot idle"></div><div class="chip-label">MATCH</div><div class="chip-value">--</div></div>
      <div class="status-chip"><div class="chip-dot idle"></div><div class="chip-label">LAST HIT</div><div class="chip-value">--</div></div>
    </div>

    <!-- Data Flow Pipeline -->
    <div class="pipeline-section" style="margin-bottom:24px;">
      <div class="panel">
        <div class="panel-title">DATA FLOW PIPELINE</div>
        <div class="pipeline" id="ops-pipeline">
          <div class="pipe-node" id="pipe-ingest" onclick="drillPipeline('ingest')">
            <div class="pipe-node-label">INGEST</div>
            <div class="pipe-node-value" id="pipe-ingest-val">--</div>
            <div class="pipe-node-sub" id="pipe-ingest-sub">queue</div>
          </div>
          <div class="pipe-arrow" id="pipe-arrow-1"></div>
          <div class="pipe-node" id="pipe-sql" onclick="drillPipeline('sql')">
            <div class="pipe-node-label">SQL WRITE</div>
            <div class="pipe-node-value" id="pipe-sql-val">--</div>
            <div class="pipe-node-sub" id="pipe-sql-sub">PiXL.Test</div>
          </div>
          <div class="pipe-arrow" id="pipe-arrow-2"></div>
          <div class="pipe-node" id="pipe-etl" onclick="drillPipeline('etl')">
            <div class="pipe-node-label">ETL PARSE</div>
            <div class="pipe-node-value" id="pipe-etl-val">--</div>
            <div class="pipe-node-sub" id="pipe-etl-sub">parsed</div>
          </div>
          <div class="pipe-arrow" id="pipe-arrow-3"></div>
          <div class="pipe-node" id="pipe-dim" onclick="drillPipeline('dim')">
            <div class="pipe-node-label">DIMENSIONS</div>
            <div class="pipe-node-value" id="pipe-dim-val">--</div>
            <div class="pipe-node-sub" id="pipe-dim-sub">Device · IP</div>
          </div>
          <div class="pipe-arrow" id="pipe-arrow-4"></div>
          <div class="pipe-node" id="pipe-visit" onclick="drillPipeline('visit')">
            <div class="pipe-node-label">VISITS</div>
            <div class="pipe-node-value" id="pipe-visit-val">--</div>
            <div class="pipe-node-sub" id="pipe-visit-sub">linked</div>
          </div>
          <div class="pipe-arrow" id="pipe-arrow-5"></div>
          <div class="pipe-node" id="pipe-match" onclick="drillPipeline('match')">
            <div class="pipe-node-label">MATCH</div>
            <div class="pipe-node-value" id="pipe-match-val">--</div>
            <div class="pipe-node-sub" id="pipe-match-sub">resolved</div>
          </div>
        </div>
        <div class="etl-grid" style="margin-top:12px;">
          <div class="etl-stat"><div class="etl-val" id="flow-5min">--</div><div class="etl-lbl">LAST 5 MIN</div></div>
          <div class="etl-stat"><div class="etl-val" id="flow-1hr">--</div><div class="etl-lbl">LAST HOUR</div></div>
          <div class="etl-stat"><div class="etl-val" id="flow-last-insert">--</div><div class="etl-lbl">LAST INSERT</div></div>
        </div>
      </div>
    </div>

    <!-- Errors + ETL + Pipeline -->
    <div class="panel-grid triple">
      <div class="panel">
        <div class="panel-title">ERROR LOG</div>
        <div class="error-log" id="error-log"><div style="color:var(--text-dim); font-size:0.78rem; padding: 20px; text-align:center;">Waiting for data...</div></div>
      </div>
      <div class="panel">
        <div class="panel-title">ETL HEALTH</div>
        <div id="etl-details"><div class="loading">LOADING</div></div>
      </div>
      <div class="panel">
        <div class="panel-title">PIPELINE TABLES</div>
        <div id="pipeline-tables"><div class="loading">LOADING</div></div>
      </div>
    </div>

    <!-- Infrastructure -->
    <div class="panel" style="margin-bottom:24px;">
      <div class="panel-title">INFRASTRUCTURE</div>
      <div id="infra-detail"><div class="loading">LOADING</div></div>
    </div>

    <!-- Live Feed (compact, 15 hits) -->
    <div class="panel" style="margin-bottom:24px;">
      <div class="panel-title">LIVE FEED — LAST 15 HITS</div>
      <div style="overflow-x:auto;">
        <table class="feed-table">
          <thead><tr><th>TIME</th><th>IP</th><th>THREAT</th><th>SCORE</th><th>PLATFORM</th><th>BROWSER</th><th>FINGERPRINT</th></tr></thead>
          <tbody id="ops-feed-body"><tr><td colspan="7" class="loading">LOADING</td></tr></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- ══════════════════════════════════════════════════════════════════════
       ANALYTICS VIEW
       ══════════════════════════════════════════════════════════════════════ -->
  <div id="view-analytics" class="view-content">
    <!-- Hero Cards -->
    <div class="hero-grid" id="hero-grid">
      <div class="hero-card" onclick="drillHero('total')"><div class="hero-label">TOTAL HITS</div><div class="hero-value" id="h-total">--</div><div class="hero-sub" id="h-total-sub"></div></div>
      <div class="hero-card" onclick="drillHero('24h')"><div class="hero-label">LAST 24H</div><div class="hero-value" id="h-24h">--</div><div class="hero-sub" id="h-24h-sub"></div></div>
      <div class="hero-card" onclick="drillHero('bots')"><div class="hero-label">BOTS DETECTED</div><div class="hero-value" id="h-bots">--</div><div class="hero-sub" id="h-bots-sub"></div></div>
      <div class="hero-card" onclick="drillHero('botpct')"><div class="hero-label">BOT RATE</div><div class="hero-value" id="h-botpct">--</div><div class="hero-sub" id="h-botpct-sub"></div></div>
      <div class="hero-card" onclick="drillHero('fp')"><div class="hero-label">UNIQUE FP</div><div class="hero-value" id="h-fp">--</div><div class="hero-sub" id="h-fp-sub"></div></div>
      <div class="hero-card" onclick="drillHero('evasion')"><div class="hero-label">EVASION</div><div class="hero-value" id="h-evasion">--</div><div class="hero-sub" id="h-evasion-sub"></div></div>
    </div>

    <!-- Pipeline (full) -->
    <div class="pipeline" id="a-pipeline" style="margin-bottom:24px;">
      <div class="pipe-node"><div class="pipe-node-label">RAW HITS</div><div class="pipe-node-value" id="a-pipe-raw">--</div></div>
      <div class="pipe-arrow"></div>
      <div class="pipe-node"><div class="pipe-node-label">ETL PARSE</div><div class="pipe-node-value" id="a-pipe-parsed">--</div></div>
      <div class="pipe-arrow"></div>
      <div class="pipe-node"><div class="pipe-node-label">VISITS</div><div class="pipe-node-value" id="a-pipe-visits">--</div></div>
      <div class="pipe-arrow"></div>
      <div class="pipe-node"><div class="pipe-node-label">MATCH</div><div class="pipe-node-value" id="a-pipe-match">--</div></div>
      <div class="pipe-arrow"></div>
      <div class="pipe-node"><div class="pipe-node-label">RESOLVED</div><div class="pipe-node-value" id="a-pipe-resolved" style="color:var(--green);">--</div></div>
    </div>

    <!-- Hourly + Risk -->
    <div class="panel-grid">
      <div class="panel">
        <div class="panel-title">HOURLY TRAFFIC</div>
        <div class="chart-container" id="hourly-chart"><div class="loading">LOADING</div></div>
      </div>
      <div class="panel">
        <div class="panel-title">RISK BREAKDOWN</div>
        <div class="risk-list" id="risk-list"><div class="loading">LOADING</div></div>
      </div>
    </div>

    <!-- Live Feed (full, 30 hits) + Signals -->
    <div class="panel-grid">
      <div class="panel">
        <div class="panel-title">LIVE FEED</div>
        <div style="overflow-x:auto;">
          <table class="feed-table">
            <thead><tr><th>TIME</th><th>IP</th><th>THREAT</th><th>SCORE</th><th>PLATFORM</th><th>BROWSER</th><th>RESOLUTION</th><th>FINGERPRINT</th><th>SIGNALS</th></tr></thead>
            <tbody id="a-feed-body"><tr><td colspan="9" class="loading">LOADING</td></tr></tbody>
          </table>
        </div>
      </div>
      <div class="panel">
        <div class="panel-title">TOP BOT SIGNALS</div>
        <div class="signal-list" id="signal-list"><div class="loading">LOADING</div></div>
      </div>
    </div>

    <!-- Evasion + Behavior + Fingerprints -->
    <div class="panel-grid triple">
      <div class="panel">
        <div class="panel-title">EVASION COUNTERMEASURES</div>
        <div class="evasion-grid" id="evasion-grid"><div class="loading">LOADING</div></div>
      </div>
      <div class="panel">
        <div class="panel-title">BEHAVIORAL ANALYSIS</div>
        <div class="behavior-compare" id="behavior-compare"><div class="loading">LOADING</div></div>
      </div>
      <div class="panel">
        <div class="panel-title">FINGERPRINT CLUSTERS</div>
        <div class="fp-cluster-list" id="fp-clusters"><div class="loading">LOADING</div></div>
      </div>
    </div>

    <!-- Devices + ETL -->
    <div class="panel-grid half">
      <div class="panel">
        <div class="panel-title">DEVICE BREAKDOWN</div>
        <div id="device-breakdown"><div class="loading">LOADING</div></div>
      </div>
      <div class="panel">
        <div class="panel-title">ETL HEALTH</div>
        <div id="a-etl-details" style="font-size:0.82rem;"><div class="loading">LOADING</div></div>
      </div>
    </div>
  </div>
</div>

<!-- SHARED MODAL (persists across views) -->
<div class="modal-overlay" id="modal-overlay" onclick="if(event.target===this)closeModal()">
  <div class="modal-panel">
    <button class="modal-close" onclick="closeModal()">&times;</button>
    <div class="modal-title" id="modal-title"></div>
    <div class="modal-body" id="modal-body"></div>
  </div>
</div>

<script>
// ============================================================================
// DATA LAYER
// ============================================================================
const API = {
  health:       () => fetchJson('/api/dash/health'),
  infra:        () => fetchJson('/api/dash/infra'),
  recent:       () => fetchJson('/api/dash/recent'),
  hourly:       (h=48) => fetchJson(`/api/dash/hourly?hours=${h}`),
  bots:         () => fetchJson('/api/dash/bots'),
  signals:      () => fetchJson('/api/dash/bot-signals'),
  devices:      () => fetchJson('/api/dash/devices'),
  evasion:      () => fetchJson('/api/dash/evasion'),
  behavior:     () => fetchJson('/api/dash/behavior'),
  fingerprints: () => fetchJson('/api/dash/fingerprints?limit=12'),
};

let lastData = {};
let isRefreshing = false;
let refreshAbort = false;

async function fetchJson(url) {
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`${res.status}`);
    return await res.json();
  } catch (e) {
    console.warn('Fetch failed:', url, e);
    return null;
  }
}

// ============================================================================
// GRID — Three.js Tron Arena (WebGL + Bloom)
// Loaded via ES module below. Stub API until module initializes.
// Contestant light-cycles race the grid, bounded by arena walls.
// ============================================================================
var Grid = { spawnOrb() {}, derezzAll() {}, emitPulse() {} };

// ============================================================================
// MODAL SYSTEM (shared)
// ============================================================================
function openModal(title, bodyHtml) {
  document.getElementById('modal-title').textContent = title;
  document.getElementById('modal-body').innerHTML = bodyHtml;
  document.getElementById('modal-overlay').classList.add('active');
}

function closeModal() {
  document.getElementById('modal-overlay').classList.remove('active');
}

document.addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    if (document.getElementById('modal-overlay').classList.contains('active')) {
      closeModal();
    } else if (currentView !== 'landing') {
      derezToLanding();
    }
  }
});

function di(label, value, cls) {
  return `<div class="detail-item"><div class="detail-label">${label}</div><div class="detail-value${cls ? ' ' + cls : ''}">${value}</div></div>`;
}

function sug(text) {
  return `<div class="suggestion"><div class="suggestion-title">TROUBLESHOOTING</div>${text}</div>`;
}

// ============================================================================
// VIEW SWITCHING — Three states: 'landing', 'ops', 'analytics'
// Landing = background only + two buttons. Clicking active tab derezzes back.
// ============================================================================
let currentView = 'landing';  // start on landing

const dashEl   = document.getElementById('dashboard');
const landingEl = document.getElementById('landing-overlay');

function setViewClasses(view) {
  document.getElementById('view-ops').className = 'view-content' + (view === 'ops' ? ' active' : '');
  document.getElementById('view-analytics').className = 'view-content' + (view === 'analytics' ? ' active' : '');
  document.getElementById('nav-ops').className = 'nav-tab' + (view === 'ops' ? ' active' : '');
  document.getElementById('nav-analytics').className = 'nav-tab' + (view === 'analytics' ? ' active' : '');
  document.getElementById('logo-sub').textContent = view === 'ops' ? 'Operations Center' : view === 'analytics' ? 'Analytics & Intelligence' : '';
  document.getElementById('etl-header-wrap').style.display = view === 'ops' ? '' : 'none';
  document.title = view === 'ops' ? 'SmartPiXL // TRON — Operations'
                 : view === 'analytics' ? 'SmartPiXL // TRON — Analytics'
                 : 'SmartPiXL // TRON';
}

// Called from landing overlay buttons
function enterView(view) {
  if (currentView === view) return;
  closeModal();
  refreshAbort = true;
  currentView = view;

  // Hide landing
  landingEl.classList.add('hidden');

  // Show + rerezz dashboard
  dashEl.classList.remove('hidden', 'derezzing');
  dashEl.classList.add('rerezzing');
  dashEl.addEventListener('animationend', function onRe() {
    dashEl.classList.remove('rerezzing');
    dashEl.removeEventListener('animationend', onRe);
  });

  setViewClasses(view);
  const url = view === 'ops' ? '/tron' : '/tron/analytics';
  history.pushState({ view }, '', url);
  window.scrollTo(0, 0);

  // Immediately render from cached pipeline data (cycles have been fetching all along)
  renderCachedData(view);
  countdown = 0; // next cycle will refresh with fresh data
}

// Render all panels from whatever lastData the pipeline has already cached
function renderCachedData(view) {
  const { health, infra, recent } = lastData;
  if (view === 'ops') {
    if (health) document.getElementById('etl-status').textContent = health.etL_Watermark ? `#${num(health.etL_Watermark)}` : '--';
    if (health || infra) {
      renderCriticalZone(buildIssues(health, infra));
      renderStatusStrip(health, infra);
      renderPipeline(health, infra);
      renderOpsETL(health, infra);
      updateOpsBeacon(health, infra);
    }
    if (infra) { renderErrorLog(infra); renderPipelineTables(infra); renderInfraDetail(infra); }
    if (recent) renderOpsFeed(recent);
  } else if (view === 'analytics') {
    if (health) { renderAnalyticsHero(health); updateAnalyticsBeacon(health); renderAnalyticsETL(health); }
    if (lastData.hourly) renderHourlyChart(lastData.hourly);
    if (lastData.bots) renderRiskList(lastData.bots);
    if (lastData.signals) renderSignals(lastData.signals);
    if (lastData.evasion) renderEvasion(lastData.evasion);
    if (lastData.behavior) renderBehavior(lastData.behavior);
    if (recent) renderAnalyticsFeed(recent);
    if (lastData.fingerprints) renderFingerprints(lastData.fingerprints);
    if (lastData.devices) renderDevices(lastData.devices);
  }
}

// Called from nav tabs — toggle: same tab = derezz to landing, diff tab = switch
function toggleView(view) {
  if (currentView === view) {
    // Derezz back to landing
    derezToLanding();
  } else if (currentView === 'landing') {
    enterView(view);
  } else {
    // Switch between views (ops ↔ analytics)
    closeModal();
    refreshAbort = true;
    currentView = view;
    setViewClasses(view);
    const url = view === 'ops' ? '/tron' : '/tron/analytics';
    history.pushState({ view }, '', url);
    window.scrollTo(0, 0);
    renderCachedData(view);
    countdown = 0;
  }
}

function derezToLanding() {
  closeModal();
  refreshAbort = true;
  currentView = 'landing';

  // Derezz animation on dashboard (cycles keep running — they track API health)
  dashEl.classList.add('derezzing');
  dashEl.addEventListener('animationend', function onDerez() {
    dashEl.classList.remove('derezzing');
    dashEl.classList.add('hidden');
    dashEl.removeEventListener('animationend', onDerez);
  });

  // Update nav — no active tab
  document.getElementById('nav-ops').className = 'nav-tab';
  document.getElementById('nav-analytics').className = 'nav-tab';

  // Show landing
  landingEl.classList.remove('hidden');

  document.title = 'SmartPiXL // TRON';
  history.pushState({ view: 'landing' }, '', '/tron');
}

window.addEventListener('popstate', (e) => {
  const view = e.state?.view || 'landing';
  if (view === 'landing') {
    currentView = 'landing';
    dashEl.classList.add('hidden');
    dashEl.classList.remove('derezzing', 'rerezzing');
    landingEl.classList.remove('hidden');
    document.getElementById('nav-ops').className = 'nav-tab';
    document.getElementById('nav-analytics').className = 'nav-tab';
    document.title = 'SmartPiXL // TRON';
  } else {
    enterView(view);
  }
});

// Start on landing
(function() {
  currentView = 'landing';
  dashEl.classList.add('hidden');
  landingEl.classList.remove('hidden');
  document.title = 'SmartPiXL // TRON';
  history.replaceState({ view: 'landing' }, '', location.pathname);
})();

// ============================================================================
// HELPERS (shared)
// ============================================================================
function num(n) { if (n == null) return '--'; return Number(n).toLocaleString(); }

function formatDuration(sec) {
  if (sec < 60) return sec + 's';
  if (sec < 3600) return Math.floor(sec/60) + 'm';
  if (sec < 86400) return Math.floor(sec/3600) + 'h ' + Math.floor((sec%3600)/60) + 'm';
  return Math.floor(sec/86400) + 'd';
}

function timeAgo(dt) {
  const d = new Date(dt);
  const sec = Math.floor((Date.now() - d.getTime()) / 1000);
  if (sec < 0) return 'just now';
  if (sec < 60) return sec + 's ago';
  if (sec < 3600) return Math.floor(sec/60) + 'm ago';
  return Math.floor(sec/3600) + 'h ago';
}

// ============================================================================
// ██████  OPERATIONS RENDERERS & DRILL-DOWNS
// ============================================================================

// ─── Drill-Down: Pipeline Nodes ───
function drillPipeline(stage) {
  const infra = lastData.infra;
  const health = lastData.health;
  if (!infra && !health) { openModal('NO DATA', '<div style="color:var(--text-dim)">Waiting for data...</div>'); return; }
  const df = infra?.dataFlow;
  const sql = infra?.sql;
  let html = '<div class="detail-grid">';

  if (stage === 'ingest') {
    html += di('Queue Depth', df?.queueDepth ?? '--', df?.queueDepth > 100 ? 'warn' : 'ok');
    html += di('Hits Last 5m', df?.hitsLast5Min ?? '--', df?.hitsLast5Min === 0 ? 'bad' : 'ok');
    html += di('Hits Last Hour', df?.hitsLastHour ?? '--', df?.hitsLastHour === 0 ? 'warn' : 'ok');
    html += di('Is Flowing', df?.isFlowing ? 'YES' : 'NO', df?.isFlowing ? 'ok' : 'bad');
    html += di('Last Insert', df?.secondsSinceLastInsert != null ? formatDuration(df.secondsSinceLastInsert) + ' ago' : '--');
    html += di('Write Service', infra?.app ? 'PID ' + infra.app.processId : '--', 'cyan');
    html += '</div>';
    html += sug('If the queue is backing up, check SQL Server connectivity and disk I/O. If hits are 0, verify that tracking requests are reaching the server (check IIS logs). The write queue should normally be near 0.');
    openModal('INGEST STAGE', html);
  }
  else if (stage === 'sql') {
    html += di('Connected', sql?.isConnected ? 'YES' : 'NO', sql?.isConnected ? 'ok' : 'bad');
    html += di('Response Time', sql?.responseMs != null ? sql.responseMs + 'ms' : '--', sql?.responseMs > 200 ? 'warn' : 'ok');
    html += di('Data Source', sql?.dataSource || '--');
    html += di('Database', sql?.database || '--');
    html += di('PiXL.Test Rows', num(sql?.testRows));
    html += di('PiXL.Parsed Rows', num(sql?.parsedRows));
    html += di('Watermark', num(sql?.watermark));
    html += di('Last ETL Run', sql?.lastEtlRun ? timeAgo(sql.lastEtlRun) : '--');
    html += '</div>';
    if (!sql?.isConnected) {
      html += sug('SQL Server is disconnected. Check that the SQL2025 instance is running:<br><code style="color:var(--cyan)">Get-Service MSSQL$SQL2025</code><br>Verify the connection string in appsettings.json points to localhost\\SQL2025.');
    } else {
      html += sug('SQL connection is healthy. PiXL.Test stores raw ingested hits. PiXL.Parsed contains ETL-processed rows with all 167+ signals materialized.');
    }
    openModal('SQL WRITE STAGE', html);
  }
  else if (stage === 'etl') {
    html += di('Watermark', num(sql?.watermark ?? health?.etL_Watermark));
    html += di('Total Processed', num(health?.etL_TotalProcessed));
    html += di('Parsed Rows', num(sql?.parsedRows ?? health?.totalHits));
    html += di('ETL Lag', df?.etlLag != null ? df.etlLag + ' rows' : '--', df?.etlLag > 50 ? 'warn' : 'ok');
    html += di('Last ETL Run', health?.etL_LastRunAt ? timeAgo(health.etL_LastRunAt) : '--');
    html += di('Synthetic Hits', num(health?.syntheticHits));
    html += '</div>';
    html += sug('ETL runs every 60 seconds via EtlBackgroundService, calling ETL.usp_ParseNewHits. If lag is high, run manually:<br><code style="color:var(--cyan)">EXEC ETL.usp_ParseNewHits</code><br>If watermark is ahead of max Test ID, reset with:<br><code style="color:var(--cyan)">UPDATE ETL.Watermark SET LastProcessedId = 0 WHERE ProcessName = \'ParseNewHits\'</code>');
    openModal('ETL PARSE STAGE', html);
  }
  else if (stage === 'dash') {
    html += di('Status', df?.isFlowing ? 'LIVE' : 'STALE', df?.isFlowing ? 'ok' : 'bad');
    html += di('ETL Lag', df?.etlLag != null ? df.etlLag + ' rows' : '--', df?.etlLag > 50 ? 'warn' : 'ok');
    html += di('Data Freshness', health?.secondsSinceLastHit != null ? formatDuration(health.secondsSinceLastHit) + ' ago' : '--');
    html += di('24h Hits', num(health?.hits_24h));
    html += di('Total Hits', num(health?.totalHits));
    html += di('Unique Fingerprints', num(health?.uniqueFP_24h));
    html += '</div>';
    html += sug('Dashboard reads from materialized views on PiXL.Parsed. If showing stale, ensure ETL is processing and that the views are querying PiXL.Parsed (not the old dbo schema).');
    openModal('DASHBOARD STAGE', html);
  }
  else if (stage === 'dim') {
    const pipe = infra?.pipeline;
    html += di('Devices', num(pipe?.deviceRows), 'cyan');
    html += di('IPs', num(pipe?.ipRows), 'cyan');
    html += di('Unique Devices in Visits', num(pipe?.uniqueDevicesInVisits));
    html += di('Unique IPs in Visits', num(pipe?.uniqueIpsInVisits));
    html += di('Last Device Activity', pipe?.deviceLatest ? timeAgo(pipe.deviceLatest) : '--');
    html += di('Last IP Activity', pipe?.ipLatest ? timeAgo(pipe.ipLatest) : '--');
    html += '</div>';
    html += sug('PiXL.Device and PiXL.IP are dimension tables populated by usp_ParseNewHits (Phases 9-10). Each stores a unique hash with first/last seen timestamps. They are keyed to Visit rows via DeviceId and IpId foreign keys.');
    openModal('DIMENSION TABLES', html);
  }
  else if (stage === 'visit') {
    const pipe = infra?.pipeline;
    html += di('Total Visits', num(pipe?.visitRows), 'cyan');
    html += di('With Email', num(pipe?.visitsWithEmail), pipe?.visitsWithEmail > 0 ? 'ok' : '');
    html += di('Max Visit ID', num(pipe?.maxVisitId));
    html += di('Last Visit', pipe?.visitLatest ? timeAgo(pipe.visitLatest) : '--');
    html += di('Parse Lag', pipe?.parseLag != null ? pipe.parseLag + ' rows' : '--', pipe?.parseLag > 50 ? 'warn' : 'ok');
    html += di('Match Lag', pipe?.matchLag != null ? pipe.matchLag + ' rows' : '--', pipe?.matchLag > 50 ? 'warn' : 'ok');
    html += '</div>';
    html += sug('PiXL.Visit is the fact table linking Device + IP per parsed hit. Visits with a MatchEmail are eligible for identity resolution via usp_MatchVisits. Match lag shows how many visits haven\'t been checked yet.');
    openModal('VISIT TABLE', html);
  }
  else if (stage === 'match') {
    const pipe = infra?.pipeline;
    html += di('Total Matches', num(pipe?.matchRows));
    html += di('Resolved', num(pipe?.matchesResolved), pipe?.matchesResolved > 0 ? 'ok' : '');
    html += di('Pending', num(pipe?.matchesPending), pipe?.matchesPending > 0 ? 'warn' : 'ok');
    html += di('Match Watermark', num(pipe?.matchWatermark));
    html += di('Processed by Match', num(pipe?.matchTotalProcessed));
    html += di('Total Matched', num(pipe?.matchTotalMatched), 'ok');
    html += di('Match Lag', pipe?.matchLag != null ? pipe.matchLag + ' rows' : '--', pipe?.matchLag > 50 ? 'warn' : 'ok');
    html += di('Last Match Run', pipe?.matchLastRunAt ? timeAgo(pipe.matchLastRunAt) : '--');
    html += '</div>';
    html += sug('PiXL.Match stores identity resolution results from usp_MatchVisits. Resolved matches have an IndividualKey + AddressKey from the AutoConsumer lookup. Pending matches had email but no AutoConsumer hit. Run manually:<br><code style="color:var(--cyan)">EXEC ETL.usp_MatchVisits @BatchSize=1000</code>');
    openModal('MATCH / IDENTITY', html);
  }
}

// ─── Drill-Down: Pipeline Table cell ───
function drillPipelineTable(table) {
  const pipe = lastData.infra?.pipeline;
  if (!pipe) return;
  let html = '<div class="detail-grid">';
  if (table === 'test') {
    html += di('Rows', num(pipe.testRows));
    html += di('Max ID', num(pipe.maxTestId));
    html += di('Latest', pipe.testLatest ? timeAgo(pipe.testLatest) : '--');
    html += di('Parse Watermark', num(pipe.parseWatermark));
    html += '</div>';
    openModal('PiXL.Test', html);
  } else if (table === 'parsed') {
    html += di('Rows', num(pipe.parsedRows));
    html += di('Parse Lag', pipe.parseLag + ' rows', pipe.parseLag > 50 ? 'warn' : 'ok');
    html += di('Latest', pipe.parsedLatest ? timeAgo(pipe.parsedLatest) : '--');
    html += di('Total Processed', num(pipe.parseTotalProcessed));
    html += '</div>';
    openModal('PiXL.Parsed', html);
  } else if (table === 'device') {
    html += di('Rows', num(pipe.deviceRows), 'cyan');
    html += di('In Visits', num(pipe.uniqueDevicesInVisits));
    html += di('Latest', pipe.deviceLatest ? timeAgo(pipe.deviceLatest) : '--');
    html += '</div>';
    openModal('PiXL.Device', html);
  } else if (table === 'ip') {
    html += di('Rows', num(pipe.ipRows), 'cyan');
    html += di('In Visits', num(pipe.uniqueIpsInVisits));
    html += di('Latest', pipe.ipLatest ? timeAgo(pipe.ipLatest) : '--');
    html += '</div>';
    openModal('PiXL.IP', html);
  } else if (table === 'visit') {
    html += di('Rows', num(pipe.visitRows));
    html += di('Max Visit ID', num(pipe.maxVisitId));
    html += di('With Email', num(pipe.visitsWithEmail));
    html += di('Latest', pipe.visitLatest ? timeAgo(pipe.visitLatest) : '--');
    html += '</div>';
    openModal('PiXL.Visit', html);
  } else if (table === 'match') {
    html += di('Rows', num(pipe.matchRows));
    html += di('Resolved', num(pipe.matchesResolved), 'ok');
    html += di('Pending', num(pipe.matchesPending), pipe.matchesPending > 0 ? 'warn' : 'ok');
    html += di('Latest', pipe.matchLatest ? timeAgo(pipe.matchLatest) : '--');
    html += '</div>';
    openModal('PiXL.Match', html);
  }
}

// ─── Drill-Down: Status Chips ───
function drillStatus(type) {
  const infra = lastData.infra;
  const health = lastData.health;
  if (!infra && !health) return;
  let html = '<div class="detail-grid">';

  if (type === 'overall') {
    html += di('Status', infra?.overallStatus?.toUpperCase() || '--', infra?.overallStatus === 'healthy' ? 'ok' : infra?.overallStatus === 'critical' ? 'bad' : 'warn');
    html += di('Probe Time', (infra?.probeTimeMs || 0) + 'ms');
    const svcUp = (infra?.services || []).filter(s => s.isRunning).length;
    const svcTotal = (infra?.services || []).length;
    html += di('Services', `${svcUp}/${svcTotal} running`, svcUp === svcTotal ? 'ok' : 'bad');
    const webUp = (infra?.websites || []).filter(w => w.isHealthy).length;
    const webTotal = (infra?.websites || []).length;
    html += di('Endpoints', `${webUp}/${webTotal} healthy`, webUp === webTotal ? 'ok' : 'bad');
    html += di('SQL', infra?.sql?.isConnected ? 'Connected' : 'Disconnected', infra?.sql?.isConnected ? 'ok' : 'bad');
    html += di('Data Flow', infra?.dataFlow?.isFlowing ? 'Active' : 'Stopped', infra?.dataFlow?.isFlowing ? 'ok' : 'bad');
    html += '</div>';
    openModal('SYSTEM OVERVIEW', html);
  }
  else if (type === 'dataflow') {
    const df = infra?.dataFlow;
    html += di('Is Flowing', df?.isFlowing ? 'YES' : 'NO', df?.isFlowing ? 'ok' : 'bad');
    html += di('Hits Last 5m', df?.hitsLast5Min ?? '--');
    html += di('Hits Last Hour', df?.hitsLastHour ?? '--');
    html += di('Queue Depth', df?.queueDepth ?? '--');
    html += di('Max Test ID', num(df?.maxTestId));
    html += di('Since Last Insert', df?.secondsSinceLastInsert != null ? formatDuration(df.secondsSinceLastInsert) : '--');
    html += di('ETL Lag', df?.etlLag != null ? df.etlLag + ' rows' : '--');
    html += di('Last Insert UTC', df?.lastInsertUtc || '--');
    html += '</div>';
    openModal('DATA FLOW DETAIL', html);
  }
  else if (type === 'sql') {
    const s = infra?.sql;
    html += di('Connected', s?.isConnected ? 'YES' : 'NO', s?.isConnected ? 'ok' : 'bad');
    html += di('Instance', s?.dataSource || '--');
    html += di('Database', s?.database || '--');
    html += di('Response', s?.responseMs != null ? s.responseMs + 'ms' : '--');
    html += di('PiXL.Test', num(s?.testRows) + ' rows');
    html += di('PiXL.Parsed', num(s?.parsedRows) + ' rows');
    html += di('Watermark', num(s?.watermark));
    html += di('Last ETL', s?.lastEtlRun ? timeAgo(s.lastEtlRun) : '--');
    html += '</div>';
    if (s?.error) html += `<div class="full-text" style="color:var(--red)">${s.error}</div>`;
    openModal('SQL SERVER DETAIL', html);
  }
  else if (type === 'iis') {
    const sites = infra?.websites || [];
    html = '<div style="display:flex;flex-direction:column;gap:8px;">';
    sites.forEach(w => {
      const ok = w.isHealthy;
      html += `<div style="display:flex;align-items:center;gap:10px;padding:10px 14px;background:rgba(0,243,255,0.03);border:1px solid ${ok ? 'rgba(0,255,136,0.15)' : 'rgba(255,45,85,0.2)'};border-radius:4px;">
        <div class="infra-dot ${ok ? 'up' : 'down'}"></div>
        <div style="flex:1;"><div style="font-weight:bold;">${w.name}</div><div style="font-size:0.75rem;color:var(--text-dim)">${w.url || ''}</div></div>
        <div style="color:${ok ? 'var(--green)' : 'var(--red)'}">${ok ? 'HTTP ' + w.statusCode : (w.error || 'HTTP ' + w.statusCode)}</div>
        <div style="color:var(--cyan-dim)">${w.responseMs}ms</div>
      </div>`;
    });
    html += '</div>';
    openModal('IIS ENDPOINTS', html);
  }
  else if (type === 'etl') {
    html += di('Watermark', num(health?.etL_Watermark));
    html += di('Total Processed', num(health?.etL_TotalProcessed));
    html += di('Parsed Rows', num(health?.totalHits));
    html += di('Last Run', health?.etL_LastRunAt ? timeAgo(health.etL_LastRunAt) : '--');
    html += di('Lag', infra?.dataFlow?.etlLag != null ? infra.dataFlow.etlLag + ' rows' : '--');
    html += di('Synthetic Hits', num(health?.syntheticHits));
    html += '</div>';
    openModal('ETL DETAIL', html);
  }
  else if (type === 'match') {
    const pipe = infra?.pipeline;
    html += di('Total Matches', num(pipe?.matchRows), 'cyan');
    html += di('Resolved', num(pipe?.matchesResolved), pipe?.matchesResolved > 0 ? 'ok' : '');
    html += di('Pending', num(pipe?.matchesPending), pipe?.matchesPending > 0 ? 'warn' : 'ok');
    html += di('Match Watermark', num(pipe?.matchWatermark));
    html += di('Total Matched', num(pipe?.matchTotalMatched), 'ok');
    html += di('Match Lag', pipe?.matchLag != null ? pipe.matchLag + ' rows' : '--', pipe?.matchLag > 50 ? 'warn' : 'ok');
    html += di('Visits With Email', num(pipe?.visitsWithEmail));
    html += di('Last Match Run', pipe?.matchLastRunAt ? timeAgo(pipe.matchLastRunAt) : '--');
    html += '</div>';
    html += sug('Identity resolution matches Visit emails against the AutoConsumer database (421M rows). Resolved = IndividualKey found. Pending = email present but no AutoConsumer match. Run manually:<br><code style="color:var(--cyan)">EXEC ETL.usp_MatchVisits @BatchSize=1000</code>');
    openModal('MATCH / IDENTITY', html);
  }
  else if (type === 'lasthit') {
    html += di('Time Since Last', health?.secondsSinceLastHit != null ? formatDuration(health.secondsSinceLastHit) : '--');
    html += di('24h Hits', num(health?.hits_24h));
    html += di('1h Hits', num(health?.hits_1h));
    html += di('7d Hits', num(health?.hits_7d));
    html += di('Bots 24h', num(health?.bots_24h));
    html += di('Bot Rate', health?.botPct_24h != null ? health.botPct_24h.toFixed(1) + '%' : '--');
    html += '</div>';
    openModal('TRAFFIC DETAIL', html);
  }
}

// ─── Drill-Down: Error Entry ───
function drillError(idx) {
  const errors = lastData.infra?.recentErrors?.errors;
  if (!errors || !errors[idx]) return;
  const e = errors[idx];
  let html = '<div class="detail-grid">';
  html += di('Source', e.source || 'Unknown');
  html += di('Count', e.count || 1);
  html += di('Last Seen', e.lastSeenUtc ? timeAgo(e.lastSeenUtc) : '--');
  html += di('Status', e.isStale ? 'Stale' : 'Active', e.isStale ? 'warn' : 'bad');
  html += '</div>';
  html += '<div class="full-text">' + (e.message || 'No message') + '</div>';
  openModal('ERROR DETAIL', html);
}

// ─── Drill-Down: Critical Issue ───
function drillIssue(idx) {
  const issues = lastData._issues;
  if (!issues || !issues[idx]) return;
  const issue = issues[idx];
  let html = '<div class="detail-grid">';
  html += di('Severity', issue.severity.toUpperCase(), issue.severity === 'critical' ? 'bad' : 'warn');
  html += di('Detected', issue.time ? timeAgo(issue.time) : 'Current');
  html += '</div>';
  html += '<div style="margin-top:16px;font-size:0.85rem;line-height:1.6;color:var(--text);">' + issue.detail + '</div>';
  const fixes = getFixSuggestion(issue);
  if (fixes) html += sug(fixes);
  openModal(issue.title, html);
}

function getFixSuggestion(issue) {
  const t = issue.title.toLowerCase();
  if (t.includes('sql') && t.includes('disconnect')) return 'Check SQL Server service:<br><code style="color:var(--cyan)">Get-Service MSSQL$SQL2025</code><br>If stopped, start it:<br><code style="color:var(--cyan)">Start-Service MSSQL$SQL2025</code>';
  if (t.includes('data not flowing')) return 'Check that the TrackingPixel process is running and that the IIS app pool identity has SQL permissions.<br><code style="color:var(--cyan)">Get-Process TrackingPixel</code>';
  if (t.includes('service down')) return 'Restart the service from PowerShell:<br><code style="color:var(--cyan)">Start-Service "ServiceName"</code>';
  if (t.includes('endpoint down') || t.includes('endpoint unhealthy')) return 'Check IIS application pool status:<br><code style="color:var(--cyan)">Get-WebAppPoolState "Smartpixl.info"</code><br>If stopped:<br><code style="color:var(--cyan)">Start-WebAppPool "Smartpixl.info"</code>';
  if (t.includes('error')) return 'Check the application log for details:<br><code style="color:var(--cyan)">Get-Content "C:\\inetpub\\Smartpixl.info\\Log\\*.log" -Tail 50</code>';
  if (t.includes('etl lag')) return 'Run the ETL manually:<br><code style="color:var(--cyan)">sqlcmd -S "localhost\\SQL2025" -d SmartPiXL -Q "EXEC ETL.usp_ParseNewHits"</code>';
  if (t.includes('match lag')) return 'Run the match proc manually:<br><code style="color:var(--cyan)">sqlcmd -S "localhost\\SQL2025" -d SmartPiXL -Q "EXEC ETL.usp_MatchVisits @BatchSize=1000"</code>';
  if (t.includes('parse lag') && t.includes('pipeline')) return 'Run the parse proc manually:<br><code style="color:var(--cyan)">sqlcmd -S "localhost\\SQL2025" -d SmartPiXL -Q "EXEC ETL.usp_ParseNewHits"</code>';
  if (t.includes('no recent hit')) return 'Verify traffic is reaching the server. Send a test hit:<br><code style="color:var(--cyan)">Invoke-WebRequest "http://192.168.88.176/TEST/verify_SMART.GIF" -UseBasicParsing</code>';
  return null;
}

// ─── Critical Issues Engine ───
function buildIssues(health, infra) {
  const issues = [];
  if (infra) {
    if (infra.overallStatus === 'critical')
      issues.push({ severity: 'critical', title: 'Infrastructure Critical', detail: 'One or more core services are down. See infrastructure panel below.', time: infra.checkedAt });
    if (infra.dataFlow && !infra.dataFlow.isFlowing)
      issues.push({ severity: 'critical', title: 'Data Not Flowing', detail: `No data ingested in ${formatDuration(infra.dataFlow.secondsSinceLastInsert || 0)}. Queue: ${infra.dataFlow.queueDepth}. Check SQL connection and write service.`, time: infra.checkedAt });
    if (infra.sql && !infra.sql.isConnected)
      issues.push({ severity: 'critical', title: 'SQL Server Disconnected', detail: infra.sql.error || 'Cannot connect to SQL Server.', time: infra.checkedAt });
    if (infra.services) {
      infra.services.filter(s => !s.isRunning && s.critical).forEach(s => issues.push({ severity: 'critical', title: `Service Down: ${s.name}`, detail: s.error || 'Critical service not running.', time: infra.checkedAt }));
      infra.services.filter(s => !s.isRunning && !s.critical).forEach(s => issues.push({ severity: 'warning', title: `Service Stopped: ${s.name}`, detail: s.error || s.status, time: infra.checkedAt }));
    }
    if (infra.websites) {
      infra.websites.filter(w => !w.isHealthy && w.critical).forEach(w => issues.push({ severity: 'critical', title: `Endpoint Down: ${w.name}`, detail: w.error || `HTTP ${w.statusCode}`, time: infra.checkedAt }));
      infra.websites.filter(w => !w.isHealthy && !w.critical).forEach(w => issues.push({ severity: 'warning', title: `Endpoint Unhealthy: ${w.name}`, detail: w.error || `HTTP ${w.statusCode}`, time: infra.checkedAt }));
    }
    if (infra.recentErrors && infra.recentErrors.hasRecentErrors) {
      const re = infra.recentErrors;
      issues.push({ severity: 'warning', title: `${re.recentErrorCount} Active Error${re.recentErrorCount > 1 ? 's' : ''} in Log`, detail: `Most recent: ${re.errors[0]?.message?.substring(0,100) || 'Unknown'}`, time: re.lastErrorUtc });
    }
    if (infra.dataFlow && infra.dataFlow.etlLag > 100)
      issues.push({ severity: 'warning', title: 'ETL Lag High', detail: `Watermark is ${infra.dataFlow.etlLag} rows behind. Parsed data may be stale.`, time: infra.checkedAt });
    if (infra.dataFlow && infra.dataFlow.queueDepth > 100)
      issues.push({ severity: 'warning', title: 'Write Queue Backing Up', detail: `Queue depth: ${infra.dataFlow.queueDepth}. Writes may be slow.`, time: infra.checkedAt });
    if (infra.pipeline && infra.pipeline.isAvailable) {
      if (infra.pipeline.matchLag > 100)
        issues.push({ severity: 'warning', title: 'Match Lag High', detail: `Match watermark is ${infra.pipeline.matchLag} visits behind. Identity resolution may be delayed.`, time: infra.checkedAt });
      if (infra.pipeline.parseLag > 100)
        issues.push({ severity: 'warning', title: 'Parse Lag High (Pipeline)', detail: `Parse watermark is ${infra.pipeline.parseLag} rows behind. Device/IP/Visit tables may be stale.`, time: infra.checkedAt });
    }
  }
  if (health) {
    const secSince = health.secondsSinceLastHit || 9999;
    if (secSince > 3600)
      issues.push({ severity: 'warning', title: 'No Recent Hits', detail: `Last hit ${formatDuration(secSince)} ago. Traffic may have stopped or ingestion is broken.`, time: null });
  }
  issues.sort((a, b) => {
    const sevOrder = { critical: 0, warning: 1 };
    return (sevOrder[a.severity] || 2) - (sevOrder[b.severity] || 2);
  });
  return issues;
}

let previousIssueCount = -1;

function renderCriticalZone(issues) {
  const zone = document.getElementById('critical-zone');
  lastData._issues = issues;

  if (!issues || issues.length === 0) {
    zone.innerHTML = `<div class="all-clear"><div class="all-clear-dot"></div><div class="all-clear-text">ALL SYSTEMS OPERATIONAL</div><div class="all-clear-sub">No issues detected</div></div>`;
    previousIssueCount = 0;
    return;
  }

  const critCount = issues.filter(i => i.severity === 'critical').length;
  const warnCount = issues.filter(i => i.severity === 'warning').length;
  const hasCritical = critCount > 0;
  const panelStyle = hasCritical ? '' : 'style="border-color:rgba(255,225,77,0.3);background:rgba(255,225,77,0.03);"';
  const iconClass = hasCritical ? '' : 'warning';
  const titleClass = hasCritical ? '' : 'warning';
  const titleText = hasCritical ? 'CRITICAL ISSUES DETECTED' : 'WARNINGS';
  const countText = `${critCount ? critCount + ' CRITICAL' : ''}${critCount && warnCount ? ' · ' : ''}${warnCount ? warnCount + ' WARNING' : ''}`;
  const shouldAnimate = previousIssueCount !== issues.length;
  zone.className = shouldAnimate ? 'slide-in' : '';

  zone.innerHTML = `
    <div class="critical-panel" ${panelStyle}>
      <div class="critical-header">
        <div class="critical-icon ${iconClass}"></div>
        <div class="critical-title ${titleClass}">${titleText}</div>
        <div class="critical-count">${countText}</div>
      </div>
      ${issues.map((issue, i) => `
        <div class="critical-issue ${issue.severity === 'warning' ? 'warning' : ''}" onclick="drillIssue(${i})">
          <div class="issue-severity ${issue.severity}">${issue.severity.toUpperCase()}</div>
          <div class="issue-body">
            <div class="issue-title">${issue.title}</div>
            <div class="issue-detail">${issue.detail}</div>
          </div>
          <div class="issue-time">${issue.time ? timeAgo(issue.time) : ''}</div>
        </div>
      `).join('')}
    </div>
  `;
  previousIssueCount = issues.length;
}

// ─── Ops: Status Strip ───
function renderStatusStrip(health, infra) {
  const strip = document.getElementById('status-strip');
  const chips = [];

  const os = infra?.overallStatus || 'unknown';
  const osDot = os === 'healthy' ? 'up' : os === 'degraded' ? 'warn' : os === 'critical' ? 'down' : 'idle';
  const osVal = os === 'healthy' ? 'ok' : os === 'degraded' ? 'warn' : os === 'critical' ? 'bad' : '';
  chips.push(`<div class="status-chip ${os}" onclick="drillStatus('overall')"><div class="chip-dot ${osDot}"></div><div class="chip-label">OVERALL</div><div class="chip-value ${osVal}">${os.toUpperCase()}</div></div>`);

  const df = infra?.dataFlow;
  const flowOk = df?.isFlowing;
  chips.push(`<div class="status-chip ${flowOk ? 'healthy' : df ? 'critical' : ''}" onclick="drillStatus('dataflow')"><div class="chip-dot ${flowOk ? 'up' : df ? 'down' : 'idle'}"></div><div class="chip-label">DATA FLOW</div><div class="chip-value ${flowOk ? 'ok' : df ? 'bad' : ''}">${flowOk ? `${df.hitsLast5Min}/5m` : df ? 'STOPPED' : '--'}</div></div>`);

  const sqlOk = infra?.sql?.isConnected;
  const sqlMs = infra?.sql?.responseMs;
  chips.push(`<div class="status-chip ${sqlOk ? 'healthy' : infra?.sql ? 'critical' : ''}" onclick="drillStatus('sql')"><div class="chip-dot ${sqlOk ? 'up' : infra?.sql ? 'down' : 'idle'}"></div><div class="chip-label">SQL</div><div class="chip-value ${sqlOk ? (sqlMs > 200 ? 'warn' : 'ok') : infra?.sql ? 'bad' : ''}">${sqlOk ? `${sqlMs}ms` : infra?.sql ? 'DOWN' : '--'}</div></div>`);

  const sites = infra?.websites || [];
  const iisDown = sites.filter(w => !w.isHealthy);
  chips.push(`<div class="status-chip ${iisDown.length ? 'critical' : sites.length ? 'healthy' : ''}" onclick="drillStatus('iis')"><div class="chip-dot ${sites.length === 0 ? 'idle' : iisDown.length === 0 ? 'up' : 'down'}"></div><div class="chip-label">IIS</div><div class="chip-value ${sites.length === 0 ? '' : iisDown.length === 0 ? 'ok' : 'bad'}">${sites.length === 0 ? '--' : iisDown.length === 0 ? `${sites.length}/${sites.length} UP` : `${iisDown.length} DOWN`}</div></div>`);

  const etlLag = df?.etlLag ?? null;
  chips.push(`<div class="status-chip ${etlLag > 50 ? 'degraded' : etlLag !== null ? 'healthy' : ''}" onclick="drillStatus('etl')"><div class="chip-dot ${etlLag === null ? 'idle' : etlLag > 50 ? 'warn' : 'up'}"></div><div class="chip-label">ETL</div><div class="chip-value ${etlLag === null ? '' : etlLag > 50 ? 'warn' : 'ok'}">${etlLag === null ? '--' : `LAG ${etlLag}`}</div></div>`);

  // Match chip — shows resolved/total
  const pipe = infra?.pipeline;
  const matchOk = pipe?.isAvailable && pipe?.matchRows > 0;
  const matchResolved = pipe?.matchesResolved ?? 0;
  const matchTotal = pipe?.matchRows ?? 0;
  const matchLag = pipe?.matchLag ?? null;
  const matchDot = !pipe?.isAvailable ? 'idle' : matchLag > 50 ? 'warn' : matchResolved > 0 ? 'up' : 'idle';
  const matchChipCls = !pipe?.isAvailable ? '' : matchLag > 50 ? 'degraded' : 'healthy';
  const matchValCls = !pipe?.isAvailable ? '' : matchResolved > 0 ? 'ok' : matchTotal > 0 ? 'warn' : '';
  const matchText = !pipe?.isAvailable ? '--' : `${matchResolved}/${matchTotal}`;
  chips.push(`<div class="status-chip ${matchChipCls}" onclick="drillStatus('match')"><div class="chip-dot ${matchDot}"></div><div class="chip-label">MATCH</div><div class="chip-value ${matchValCls}">${matchText}</div></div>`);

  const secSince = health?.secondsSinceLastHit ?? null;
  const hitDot = secSince === null ? 'idle' : secSince < 300 ? 'up' : secSince < 3600 ? 'warn' : 'down';
  const hitVal = secSince === null ? '--' : secSince < 60 ? `${secSince}s ago` : formatDuration(secSince) + ' ago';
  const hitCls = secSince === null ? '' : secSince < 300 ? 'ok' : secSince < 3600 ? 'warn' : 'bad';
  const hitChipCls = secSince === null ? '' : secSince < 300 ? 'healthy' : secSince < 3600 ? 'degraded' : 'critical';
  chips.push(`<div class="status-chip ${hitChipCls}" onclick="drillStatus('lasthit')"><div class="chip-dot ${hitDot}"></div><div class="chip-label">LAST HIT</div><div class="chip-value ${hitCls}">${hitVal}</div></div>`);

  strip.innerHTML = chips.join('');
}

// ─── Ops: Pipeline ───
function renderPipeline(health, infra) {
  const df = infra?.dataFlow;
  const sql = infra?.sql;
  const pipe = infra?.pipeline;

  // Node 1: INGEST
  const queueDepth = df?.queueDepth ?? (infra?.app?.queueDepth ?? '--');
  document.getElementById('pipe-ingest-val').textContent = queueDepth;
  document.getElementById('pipe-ingest-sub').textContent = 'in queue';
  document.getElementById('pipe-ingest').className = 'pipe-node' + (queueDepth > 100 ? ' stale' : queueDepth !== '--' ? ' healthy' : '');

  // Node 2: SQL WRITE
  const maxTestId = pipe?.maxTestId ?? (df?.maxTestId ?? (sql?.testRows ?? '--'));
  document.getElementById('pipe-sql-val').textContent = typeof maxTestId === 'number' ? num(maxTestId) : maxTestId;
  document.getElementById('pipe-sql-sub').textContent = 'PiXL.Test';
  document.getElementById('pipe-sql').className = 'pipe-node' + (sql?.isConnected === false ? ' down' : sql?.isConnected ? ' healthy' : '');
  document.getElementById('pipe-arrow-1').className = 'pipe-arrow' + (sql?.isConnected === false ? ' dead' : '');

  // Node 3: ETL PARSE
  const parsedRows = pipe?.parsedRows ?? (sql?.parsedRows ?? (health?.totalHits ?? '--'));
  document.getElementById('pipe-etl-val').textContent = typeof parsedRows === 'number' ? num(parsedRows) : parsedRows;
  document.getElementById('pipe-etl-sub').textContent = pipe ? `lag ${pipe.parseLag}` : 'PiXL.Parsed';
  const parseLag = pipe?.parseLag ?? (df?.etlLag ?? null);
  document.getElementById('pipe-etl').className = 'pipe-node' + (parseLag > 50 ? ' stale' : parseLag !== null ? ' healthy' : '');
  document.getElementById('pipe-arrow-2').className = 'pipe-arrow' + (parseLag > 50 ? ' dead' : '');

  // Node 4: DIMENSIONS (Device + IP)
  const devCount = pipe?.deviceRows ?? '--';
  const ipCount = pipe?.ipRows ?? '--';
  document.getElementById('pipe-dim-val').textContent = typeof devCount === 'number' ? `${num(devCount)}+${num(ipCount)}` : '--';
  document.getElementById('pipe-dim-sub').textContent = 'Device · IP';
  document.getElementById('pipe-dim').className = 'pipe-node' + (pipe?.isAvailable ? ' healthy' : '');
  document.getElementById('pipe-arrow-3').className = 'pipe-arrow' + (pipe?.isAvailable === false ? ' dead' : '');

  // Node 5: VISITS
  const visitCount = pipe?.visitRows ?? '--';
  document.getElementById('pipe-visit-val').textContent = typeof visitCount === 'number' ? num(visitCount) : visitCount;
  document.getElementById('pipe-visit-sub').textContent = pipe ? `${num(pipe.visitsWithEmail||0)} w/email` : 'linked';
  document.getElementById('pipe-visit').className = 'pipe-node' + (pipe?.isAvailable ? ' healthy' : '');
  document.getElementById('pipe-arrow-4').className = 'pipe-arrow' + (pipe?.isAvailable === false ? ' dead' : '');

  // Node 6: MATCH
  const matchTotal = pipe?.matchRows ?? '--';
  const matchResolved = pipe?.matchesResolved ?? 0;
  document.getElementById('pipe-match-val').textContent = typeof matchTotal === 'number' ? num(matchTotal) : matchTotal;
  document.getElementById('pipe-match-sub').textContent = pipe ? `${matchResolved} resolved` : 'resolved';
  const matchLag = pipe?.matchLag ?? null;
  const matchOk = pipe?.isAvailable && matchLag !== null;
  document.getElementById('pipe-match').className = 'pipe-node' + (matchLag > 50 ? ' stale' : matchOk ? ' healthy' : '');
  document.getElementById('pipe-arrow-5').className = 'pipe-arrow' + (matchLag > 50 ? ' dead' : '');

  // Flow stats bar
  if (df) {
    const staleStr = df.secondsSinceLastInsert > 0 ? formatDuration(df.secondsSinceLastInsert) + ' ago' : 'just now';
    document.getElementById('flow-5min').textContent = df.hitsLast5Min;
    document.getElementById('flow-5min').className = 'etl-val' + (df.hitsLast5Min === 0 ? ' bad' : '');
    document.getElementById('flow-1hr').textContent = df.hitsLastHour;
    document.getElementById('flow-1hr').className = 'etl-val' + (df.hitsLastHour === 0 ? ' warn' : '');
    document.getElementById('flow-last-insert').textContent = staleStr;
    document.getElementById('flow-last-insert').className = 'etl-val' + (df.secondsSinceLastInsert > 300 ? ' warn' : '');
    document.getElementById('flow-last-insert').style.fontSize = '0.8rem';
  }
}

// ─── Ops: Error Log ───
function renderErrorLog(infra) {
  const el = document.getElementById('error-log');
  const re = infra?.recentErrors;
  if (!re || !re.hasErrors) {
    el.innerHTML = '<div style="color:var(--green); font-size:0.82rem; padding: 16px; text-align:center; letter-spacing: 2px;">NO ERRORS TODAY</div>';
    return;
  }
  el.innerHTML = re.errors.map((e, i) => {
    const isStale = e.isStale;
    const countBadge = e.count > 1 ? `<span class="error-count">x${e.count}</span>` : '';
    const ageStr = e.lastSeenUtc ? timeAgo(e.lastSeenUtc) : '';
    return `<div class="error-entry ${isStale ? 'stale' : ''}" onclick="drillError(${i})">
      <div class="error-source">${e.source || '?'}</div>
      <div class="error-msg ${isStale ? 'stale' : ''}">${e.message?.substring(0, 150) || 'Unknown error'}${e.message?.length > 150 ? '...' : ''}</div>
      ${countBadge}
      <div class="error-age">${ageStr}</div>
    </div>`;
  }).join('');
}

// ─── Ops: ETL Health ───
function renderOpsETL(health, infra) {
  const el = document.getElementById('etl-details');
  const pipe = infra?.pipeline;
  if (!health && !pipe) { el.innerHTML = '<div style="color:var(--text-dim)">No health data</div>'; return; }

  const parseLag = pipe?.parseLag ?? 0;
  const matchLag = pipe?.matchLag ?? 0;
  const parseLagCls = parseLag > 50 ? ' warn' : parseLag > 100 ? ' bad' : '';
  const matchLagCls = matchLag > 50 ? ' warn' : matchLag > 100 ? ' bad' : '';

  el.innerHTML = `
    <div style="font-family:var(--display);font-size:0.7rem;font-weight:600;letter-spacing:2px;color:var(--cyan-dim);margin-bottom:8px;">PARSE (usp_ParseNewHits)</div>
    <div class="etl-grid">
      <div class="etl-stat"><div class="etl-val">${num(pipe?.parseTotalProcessed || health?.etL_TotalProcessed || 0)}</div><div class="etl-lbl">PROCESSED</div></div>
      <div class="etl-stat"><div class="etl-val">${num(pipe?.parseWatermark || health?.etL_Watermark || 0)}</div><div class="etl-lbl">WATERMARK</div></div>
      <div class="etl-stat"><div class="etl-val${parseLagCls}">${parseLag}</div><div class="etl-lbl">PARSE LAG</div></div>
    </div>
    <div style="font-size:0.72rem;color:var(--text-dim);text-align:center;margin:6px 0 14px;">Last run: ${pipe?.parseLastRunAt ? timeAgo(pipe.parseLastRunAt) : (health?.etL_LastRunAt ? timeAgo(health.etL_LastRunAt) : '--')}</div>
    <div style="font-family:var(--display);font-size:0.7rem;font-weight:600;letter-spacing:2px;color:var(--cyan-dim);margin-bottom:8px;">MATCH (usp_MatchVisits)</div>
    <div class="etl-grid">
      <div class="etl-stat"><div class="etl-val">${num(pipe?.matchTotalProcessed || 0)}</div><div class="etl-lbl">PROCESSED</div></div>
      <div class="etl-stat"><div class="etl-val" style="color:var(--green);text-shadow:0 0 10px rgba(0,255,136,0.2)">${num(pipe?.matchTotalMatched || 0)}</div><div class="etl-lbl">MATCHED</div></div>
      <div class="etl-stat"><div class="etl-val${matchLagCls}">${matchLag}</div><div class="etl-lbl">MATCH LAG</div></div>
    </div>
    <div style="font-size:0.72rem;color:var(--text-dim);text-align:center;margin-top:6px;">Last run: ${pipe?.matchLastRunAt ? timeAgo(pipe.matchLastRunAt) : '--'}</div>
  `;
}

// ─── Ops: Pipeline Tables ───
function renderPipelineTables(infra) {
  const el = document.getElementById('pipeline-tables');
  const pipe = infra?.pipeline;
  if (!pipe?.isAvailable) { el.innerHTML = '<div style="color:var(--text-dim);font-size:0.78rem;padding:20px;text-align:center;">Pipeline data unavailable</div>'; return; }

  const tbl = (label, rows, latest, color) => {
    const age = latest ? timeAgo(latest) : '--';
    return `<div class="etl-stat" style="cursor:pointer;" onclick="drillPipelineTable('${label.toLowerCase()}')">
      <div class="etl-val" style="color:${color}">${num(rows)}</div>
      <div class="etl-lbl">${label}</div>
      <div style="font-size:0.62rem;color:var(--text-dim);margin-top:2px;">${age}</div>
    </div>`;
  };

  el.innerHTML = `
    <div class="etl-grid" style="grid-template-columns:repeat(3,1fr);">
      ${tbl('TEST', pipe.testRows, pipe.testLatest, 'var(--text)')}
      ${tbl('PARSED', pipe.parsedRows, pipe.parsedLatest, 'var(--cyan)')}
      ${tbl('DEVICE', pipe.deviceRows, pipe.deviceLatest, 'var(--cyan)')}
      ${tbl('IP', pipe.ipRows, pipe.ipLatest, 'var(--cyan)')}
      ${tbl('VISIT', pipe.visitRows, pipe.visitLatest, 'var(--cyan)')}
      ${tbl('MATCH', pipe.matchRows, pipe.matchLatest, 'var(--green)')}
    </div>
    <div style="display:flex;justify-content:space-between;margin-top:10px;padding:8px 12px;background:rgba(0,255,136,0.04);border:1px solid rgba(0,255,136,0.15);border-radius:4px;">
      <div style="text-align:center;flex:1;">
        <div style="font-family:var(--display);font-size:1.1rem;font-weight:700;color:var(--green);text-shadow:0 0 10px rgba(0,255,136,0.2)">${pipe.matchesResolved}</div>
        <div style="font-size:0.65rem;color:var(--text-dim);letter-spacing:1px;text-transform:uppercase;">RESOLVED</div>
      </div>
      <div style="text-align:center;flex:1;">
        <div style="font-family:var(--display);font-size:1.1rem;font-weight:700;color:var(--yellow)">${pipe.matchesPending}</div>
        <div style="font-size:0.65rem;color:var(--text-dim);letter-spacing:1px;text-transform:uppercase;">PENDING</div>
      </div>
      <div style="text-align:center;flex:1;">
        <div style="font-family:var(--display);font-size:1.1rem;font-weight:700;color:var(--cyan)">${num(pipe.visitsWithEmail)}</div>
        <div style="font-size:0.65rem;color:var(--text-dim);letter-spacing:1px;text-transform:uppercase;">W/ EMAIL</div>
      </div>
    </div>
    <div style="font-size:0.68rem;color:var(--text-dim);text-align:center;margin-top:6px;">${num(pipe.uniqueDevicesInVisits)} unique devices · ${num(pipe.uniqueIpsInVisits)} unique IPs in visits</div>
  `;
}

// ─── Ops: Infrastructure Detail ───
function renderInfraDetail(infra) {
  const el = document.getElementById('infra-detail');
  if (!infra) { el.innerHTML = '<div style="color:var(--text-dim)">Infrastructure probe unavailable</div>'; return; }
  let html = '<div class="infra-grid">';

  html += '<div>';
  html += '<div class="infra-group-title">Windows Services</div>';
  if (infra.services && infra.services.length) {
    infra.services.forEach(s => {
      const dotCls = s.isRunning ? 'up' : 'down';
      const detail = s.isRunning ? s.status : (s.error || s.status);
      const critTag = s.critical ? ' <span style="color:var(--red);font-size:0.65rem;font-weight:600;">CRITICAL</span>' : '';
      html += `<div class="infra-item"><div class="infra-dot ${dotCls}"></div><div class="infra-item-name">${s.name}${critTag}</div><div class="infra-item-detail">${detail}</div></div>`;
    });
  } else { html += '<div style="color:var(--text-dim);font-size:0.78rem;">No service data</div>'; }
  html += '</div>';

  html += '<div>';
  html += '<div class="infra-group-title">Website Endpoints</div>';
  if (infra.websites && infra.websites.length) {
    infra.websites.forEach(w => {
      const dotCls = w.isHealthy ? 'up' : 'down';
      const statusTxt = w.isHealthy ? `${w.statusCode} OK` : (w.error || `HTTP ${w.statusCode}`);
      const critTag = w.critical ? ' <span style="color:var(--red);font-size:0.65rem;font-weight:600;">CRITICAL</span>' : '';
      html += `<div class="infra-item"><div class="infra-dot ${dotCls}"></div><div class="infra-item-name">${w.name}${critTag}</div><div class="infra-item-detail">${statusTxt}</div><div class="infra-item-ms">${w.responseMs}ms</div></div>`;
    });
  } else { html += '<div style="color:var(--text-dim);font-size:0.78rem;">No website data</div>'; }
  html += '</div>';

  html += '<div>';
  html += '<div class="infra-group-title">SQL Server</div>';
  if (infra.sql) {
    const s = infra.sql;
    html += `<div class="infra-item"><div class="infra-dot ${s.isConnected ? 'up' : 'down'}"></div><div class="infra-item-name">${s.dataSource || 'SQL Server'} / ${s.database || '?'}</div><div class="infra-item-ms">${s.responseMs}ms</div></div>`;
    if (s.isConnected) {
      html += `<div style="font-size:0.78rem;color:var(--text-dim);padding:4px 0 0 18px;">PiXL.Test: ${num(s.testRows)} · PiXL.Parsed: ${num(s.parsedRows)} · Watermark: ${num(s.watermark)}</div>`;
      if (s.lastEtlRun) html += `<div style="font-size:0.72rem;color:var(--text-dim);padding:2px 0 0 18px;">Last ETL: ${timeAgo(s.lastEtlRun)}</div>`;
    } else {
      html += `<div style="font-size:0.78rem;color:var(--red);padding:4px 0 0 18px;">${s.error || 'Connection failed'}</div>`;
    }
  }
  html += '</div>';

  html += '<div>';
  html += '<div class="infra-group-title">App Runtime</div>';
  if (infra.app) {
    const a = infra.app;
    const uptimeSec = a.uptime ? (a.uptime.totalSeconds || (a.uptime.hours * 3600 + a.uptime.minutes * 60 + a.uptime.seconds) || 0) : 0;
    const uptimeStr = uptimeSec > 86400 ? Math.floor(uptimeSec/86400) + 'd ' + Math.floor((uptimeSec%86400)/3600) + 'h' :
                      uptimeSec > 3600 ? Math.floor(uptimeSec/3600) + 'h ' + Math.floor((uptimeSec%3600)/60) + 'm' :
                      Math.floor(uptimeSec/60) + 'm';
    html += `<div class="infra-app-grid">
      <div class="infra-app-stat"><div class="infra-app-val">${a.processId}</div><div class="infra-app-lbl">PID</div></div>
      <div class="infra-app-stat"><div class="infra-app-val">${uptimeStr}</div><div class="infra-app-lbl">UPTIME</div></div>
      <div class="infra-app-stat"><div class="infra-app-val">${a.workingSetMB}</div><div class="infra-app-lbl">MEM (MB)</div></div>
      <div class="infra-app-stat"><div class="infra-app-val">${a.threadCount}</div><div class="infra-app-lbl">THREADS</div></div>
      <div class="infra-app-stat"><div class="infra-app-val">${a.gcHeapMB}</div><div class="infra-app-lbl">GC HEAP</div></div>
      <div class="infra-app-stat"><div class="infra-app-val" style="${a.queueDepth > 100 ? 'color:var(--yellow)' : ''}">${a.queueDepth}</div><div class="infra-app-lbl">WRITE QUEUE</div></div>
    </div>`;
    html += `<div style="font-size:0.68rem;color:var(--text-dim);margin-top:6px;">${a.machineName} · .NET ${a.dotNetVersion}</div>`;
  }
  html += '</div>';
  html += '</div>';

  const checkedAt = infra.checkedAt ? new Date(infra.checkedAt).toLocaleTimeString('en',{hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:false}) + ' UTC' : '--';
  html += `<div style="text-align:right;font-size:0.68rem;color:var(--text-dim);margin-top:12px;letter-spacing:1px;">Probed in ${infra.probeTimeMs || 0}ms · ${checkedAt}</div>`;
  el.innerHTML = html;
}

// ─── Ops: Compact Live Feed ───
function renderOpsFeed(data) {
  const tbody = document.getElementById('ops-feed-body');
  if (!data || !data.length) { tbody.innerHTML = '<tr><td colspan="7" style="color:var(--text-dim)">No recent hits</td></tr>'; return; }
  tbody.innerHTML = data.slice(0, 15).map((r, i) => {
    const t = r.threatLevel || 'OK';
    const badgeClass = t === 'HIGH' ? 'high' : t === 'MED' ? 'med' : t === 'LOW' ? 'low' : 'ok';
    const time = r.receivedAt ? new Date(r.receivedAt).toLocaleTimeString('en',{hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:false}) : '--';
    return `<tr onclick="drillHit(${i})">
      <td>${time}</td>
      <td>${r.ipAddress || '--'}</td>
      <td><span class="badge ${badgeClass}">${t}</span></td>
      <td>${r.botScore ?? '--'}</td>
      <td>${r.platform || '--'}</td>
      <td>${r.browser || '--'}</td>
      <td style="color:var(--cyan)">${r.fP_Short || '--'}</td>
    </tr>`;
  }).join('');
}

// ─── Ops: Header Beacon ───
function updateOpsBeacon(health, infra) {
  const beacon = document.getElementById('beacon');
  const statusEl = document.getElementById('system-status');

  if (infra?.overallStatus === 'critical') {
    beacon.className = 'beacon-dot danger';
    statusEl.textContent = 'CRITICAL';
    statusEl.style.color = 'var(--red)';
  } else if (infra?.overallStatus === 'degraded') {
    beacon.className = 'beacon-dot warn';
    statusEl.textContent = 'DEGRADED';
    statusEl.style.color = 'var(--yellow)';
  } else if (health) {
    const secSince = health.secondsSinceLastHit || 9999;
    if (secSince < 300) {
      beacon.className = 'beacon-dot';
      statusEl.textContent = 'ONLINE';
      statusEl.style.color = '';
    } else if (secSince < 3600) {
      beacon.className = 'beacon-dot warn';
      statusEl.textContent = 'IDLE — ' + formatDuration(secSince);
      statusEl.style.color = 'var(--yellow)';
    } else {
      beacon.className = 'beacon-dot danger';
      statusEl.textContent = 'STALE — ' + formatDuration(secSince);
      statusEl.style.color = 'var(--red)';
    }
  }

  if (health) {
    document.getElementById('etl-status').textContent =
      health.etL_Watermark ? `#${num(health.etL_Watermark)}` : '--';
  }
}

// ============================================================================
// ██████  ANALYTICS RENDERERS & DRILL-DOWNS
// ============================================================================

// ─── Drill-Down: Hit (shared by both views) ───
function drillHit(idx) {
  const hits = lastData.recent;
  if (!hits || !hits[idx]) return;
  const r = hits[idx];
  let html = '<div class="detail-grid">';
  html += di('Time', r.receivedAt ? new Date(r.receivedAt).toISOString() : '--');
  html += di('IP Address', r.ipAddress || '--');
  html += di('Threat Level', r.threatLevel || 'OK', r.threatLevel === 'HIGH' ? 'bad' : r.threatLevel === 'MED' ? 'warn' : 'ok');
  html += di('Bot Score', r.botScore ?? '--', r.botScore >= 50 ? 'bad' : r.botScore >= 20 ? 'warn' : 'ok');
  html += di('Platform', r.platform || '--');
  html += di('Browser', r.browser || '--');
  html += di('Resolution', r.resolution || '--');
  html += di('Fingerprint', r.fP_Short || '--', 'cyan');
  html += '</div>';
  if (r.botSignalsList) {
    html += '<div style="margin-top:16px;"><div class="detail-label" style="margin-bottom:8px;">BOT SIGNALS</div>';
    html += '<div class="full-text">' + r.botSignalsList + '</div></div>';
  }
  openModal('HIT DETAIL', html);
}

// ─── Drill-Down: Hero Cards ───
function drillHero(type) {
  const h = lastData.health;
  if (!h) return;
  let html = '<div class="detail-grid">';
  if (type === 'total') {
    html += di('Total All Time', num(h.totalHits));
    html += di('Last 7 Days', num(h.hits_7d));
    html += di('Last 24 Hours', num(h.hits_24h));
    html += di('Last 1 Hour', num(h.hits_1h));
    html += di('ETL Processed', num(h.etL_TotalProcessed));
    html += di('Synthetic', num(h.syntheticHits));
  } else if (type === '24h') {
    html += di('24h Hits', num(h.hits_24h));
    html += di('1h Hits', num(h.hits_1h));
    html += di('7d Hits', num(h.hits_7d));
    html += di('Seconds Since Last', h.secondsSinceLastHit ?? '--');
    html += di('Bots 24h', num(h.bots_24h));
    html += di('Bot Rate 24h', (h.botPct_24h||0).toFixed(1) + '%');
  } else if (type === 'bots') {
    html += di('Bots 24h', num(h.bots_24h));
    html += di('High Risk Bots', num(h.highRiskBots_24h));
    html += di('Bot Rate', (h.botPct_24h||0).toFixed(1) + '%');
    html += di('Avg Bot Score', (h.avgBotScore_24h||0).toFixed(1));
    html += di('WebDriver Hits', num(h.webDriverHits));
    html += di('Evasion Detected', num(h.evasionDetected_AllTime));
  } else if (type === 'botpct') {
    html += di('Bot Rate 24h', (h.botPct_24h||0).toFixed(1) + '%', h.botPct_24h > 30 ? 'bad' : h.botPct_24h > 10 ? 'warn' : 'ok');
    html += di('Avg Bot Score', (h.avgBotScore_24h||0).toFixed(1));
    html += di('Total Bots 24h', num(h.bots_24h));
    html += di('Total Hits 24h', num(h.hits_24h));
  } else if (type === 'fp') {
    html += di('Unique FP 24h', num(h.uniqueFP_24h));
    html += di('Unique FP All Time', num(h.uniqueFP_AllTime));
    html += di('Total Hits', num(h.totalHits));
    html += di('Hits per FP (avg)', h.uniqueFP_AllTime ? (h.totalHits / h.uniqueFP_AllTime).toFixed(1) : '--');
  } else if (type === 'evasion') {
    html += di('Evasion Detected', num(h.evasionDetected_AllTime));
    html += di('WebDriver Hits', num(h.webDriverHits));
    html += di('Bot Rate', (h.botPct_24h||0).toFixed(1) + '%');
    html += di('High Risk Bots', num(h.highRiskBots_24h));
  }
  html += '</div>';
  openModal(type.toUpperCase() + ' DETAIL', html);
}

// ─── Drill-Down: Risk Row ───
function drillRisk(idx) {
  const bots = lastData.bots;
  if (!bots || !bots[idx]) return;
  const b = bots[idx];
  let html = '<div class="detail-grid">';
  html += di('Risk Bucket', b.riskBucket);
  html += di('Hit Count', num(b.hitCount));
  html += di('Unique Devices', num(b.uniqueDevices));
  html += di('Unique IPs', num(b.uniqueIPs));
  html += '</div>';
  openModal(b.riskBucket.toUpperCase(), html);
}

// ─── Drill-Down: Fingerprint ───
function drillFP(idx) {
  const fps = lastData.fingerprints;
  if (!fps || !fps[idx]) return;
  const fp = fps[idx];
  let html = '<div class="detail-grid">';
  html += di('Canvas Fingerprint', fp.canvasFingerprint || '--', 'cyan');
  html += di('Hit Count', num(fp.hitCount));
  html += di('Unique IPs', num(fp.uniqueIPs));
  html += di('Avg Bot Score', fp.avgBotScore != null ? fp.avgBotScore.toFixed(1) : '--', fp.avgBotScore >= 50 ? 'bad' : fp.avgBotScore >= 20 ? 'warn' : 'ok');
  html += di('Primary Platform', fp.primaryPlatform || '--');
  html += di('First Seen', fp.firstSeen ? new Date(fp.firstSeen).toLocaleDateString() : '--');
  html += '</div>';
  openModal('FINGERPRINT CLUSTER', html);
}

// ─── Drill-Down: Signal ───
function drillSignal(idx) {
  const signals = lastData.signals;
  if (!signals || !signals[idx]) return;
  const s = signals[idx];
  let html = '<div class="detail-grid">';
  html += di('Signal Name', s.signal, 'cyan');
  html += di('Times Triggered', num(s.timesTriggered));
  html += di('Unique Devices', num(s.uniqueDevices));
  html += '</div>';
  openModal('SIGNAL DETAIL', html);
}

// ─── Drill-Down: Hourly ───
function drillHour(idx) {
  const rows = lastData._hourlyRows;
  if (!rows || !rows[idx]) return;
  const r = rows[idx];
  let html = '<div class="detail-grid">';
  html += di('Hour', r.hourBucket);
  html += di('Total Hits', num(r.totalHits));
  html += di('Bot Hits', num(r.botHits), r.botHits > 0 ? 'bad' : 'ok');
  html += di('Human Hits', num((r.totalHits||0) - (r.botHits||0)), 'ok');
  html += '</div>';
  openModal('HOURLY DETAIL', html);
}

// ─── Analytics: Hero ───
function renderAnalyticsHero(h) {
  if (!h) return;
  const set = (id, val, sub) => {
    const el = document.getElementById(id);
    if (el) el.textContent = val;
    const subEl = document.getElementById(id + '-sub');
    if (subEl && sub) subEl.textContent = sub;
  };
  set('h-total', num(h.totalHits), `${num(h.hits_7d)} last 7d`);
  set('h-24h', num(h.hits_24h), `${num(h.hits_1h)} last hour`);
  set('h-bots', num(h.bots_24h), `${num(h.highRiskBots_24h)} high risk`);

  const pct = h.botPct_24h || 0;
  const pctEl = document.getElementById('h-botpct');
  pctEl.textContent = pct.toFixed(1) + '%';
  pctEl.className = 'hero-value' + (pct > 30 ? ' danger' : pct > 10 ? ' warn' : ' good');
  document.getElementById('h-botpct-sub').textContent = `avg score ${(h.avgBotScore_24h||0).toFixed(1)}`;

  set('h-fp', num(h.uniqueFP_24h), `${num(h.uniqueFP_AllTime)} all time`);

  const evEl = document.getElementById('h-evasion');
  evEl.textContent = num(h.evasionDetected_AllTime);
  evEl.className = 'hero-value' + (h.evasionDetected_AllTime > 0 ? ' warn' : ' good');
  document.getElementById('h-evasion-sub').textContent = `${num(h.webDriverHits)} webdriver`;

  document.getElementById('a-pipe-raw').textContent = num(h.etL_TotalProcessed || h.totalHits);
  document.getElementById('a-pipe-parsed').textContent = num(h.totalHits);

  // Pipeline nodes (updated from infra if available)
  const pipe = lastData.infra?.pipeline;
  if (pipe?.isAvailable) {
    document.getElementById('a-pipe-visits').textContent = num(pipe.visitRows);
    document.getElementById('a-pipe-match').textContent = num(pipe.matchRows);
    document.getElementById('a-pipe-resolved').textContent = num(pipe.matchesResolved);
    document.getElementById('a-pipe-resolved').style.color = pipe.matchesResolved > 0 ? 'var(--green)' : 'var(--text-dim)';
  }
}

// ─── Analytics: Beacon ───
function updateAnalyticsBeacon(h) {
  if (!h) return;
  const beacon = document.getElementById('beacon');
  const statusEl = document.getElementById('system-status');
  const secSince = h.secondsSinceLastHit || 9999;
  if (secSince < 300) {
    beacon.className = 'beacon-dot';
    statusEl.textContent = 'SYSTEM ONLINE';
    statusEl.style.color = '';
  } else if (secSince < 3600) {
    beacon.className = 'beacon-dot warn';
    statusEl.textContent = 'IDLE — ' + formatDuration(secSince);
    statusEl.style.color = 'var(--yellow)';
  } else {
    beacon.className = 'beacon-dot danger';
    statusEl.textContent = 'STALE — ' + formatDuration(secSince);
    statusEl.style.color = 'var(--red)';
  }
}

// ─── Analytics: ETL Details ───
function renderAnalyticsETL(h) {
  const el = document.getElementById('a-etl-details');
  if (!h) return;
  const pipe = lastData.infra?.pipeline;
  el.innerHTML = `
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 12px;">
      <div class="evasion-card"><div class="evasion-val">${num(pipe?.parseTotalProcessed || h.etL_TotalProcessed||0)}</div><div class="evasion-lbl">ROWS PROCESSED</div></div>
      <div class="evasion-card"><div class="evasion-val">${num(pipe?.parseWatermark || h.etL_Watermark||0)}</div><div class="evasion-lbl">WATERMARK ID</div></div>
      <div class="evasion-card"><div class="evasion-val">${num(h.totalHits)}</div><div class="evasion-lbl">PARSED ROWS</div></div>
      <div class="evasion-card"><div class="evasion-val">${num(pipe?.visitRows||0)}</div><div class="evasion-lbl">VISITS</div></div>
      <div class="evasion-card"><div class="evasion-val" style="color:var(--green)">${num(pipe?.matchesResolved||0)}</div><div class="evasion-lbl">MATCHED</div></div>
      <div class="evasion-card"><div class="evasion-val">${num(pipe?.deviceRows||0)}</div><div class="evasion-lbl">DEVICES</div></div>
    </div>
    <div style="font-size:0.72rem;color:var(--text-dim);text-align:center;margin-top:6px;">Parse: ${pipe?.parseLastRunAt ? timeAgo(pipe.parseLastRunAt) : (h.etL_LastRunAt ? timeAgo(h.etL_LastRunAt) : '--')} · Match: ${pipe?.matchLastRunAt ? timeAgo(pipe.matchLastRunAt) : '--'}</div>
  `;
}

// ─── Analytics: Hourly Chart ───
function renderHourlyChart(data) {
  const container = document.getElementById('hourly-chart');
  if (!data || !data.length) { container.innerHTML = '<div class="loading">NO DATA</div>'; return; }
  const rows = [...data].reverse().slice(-48);
  const maxHits = Math.max(...rows.map(r => r.totalHits || 1));

  container.innerHTML = rows.map((r, i) => {
    const total = r.totalHits || 0;
    const bots = r.botHits || 0;
    const humans = total - bots;
    const humanH = Math.max(1, (humans / maxHits) * 180);
    const botH = Math.max(0, (bots / maxHits) * 180);
    const hour = new Date(r.hourBucket).getUTCHours();
    const label = hour === 0 ? new Date(r.hourBucket).toLocaleDateString('en',{month:'short',day:'numeric',timeZone:'UTC'}) : `${hour}h`;
    return `<div class="chart-bar-group" title="${total} hits (${bots} bots) at ${r.hourBucket}" onclick="drillHour(${i})">
      <div class="chart-bar bot" style="height:${botH}px"></div>
      <div class="chart-bar human" style="height:${humanH}px"></div>
      ${hour % 6 === 0 ? `<div class="chart-label">${label}</div>` : ''}
    </div>`;
  }).join('');
  lastData._hourlyRows = rows;
}

// ─── Analytics: Risk List ───
function renderRiskList(data) {
  const el = document.getElementById('risk-list');
  if (!data || !data.length) { el.innerHTML = '<div style="color:var(--text-dim);font-size:0.78rem;">No data</div>'; return; }
  const indicatorClass = b => {
    if (b.riskBucket === 'High Risk') return 'high';
    if (b.riskBucket === 'Medium Risk') return 'medium';
    if (b.riskBucket === 'Low Risk') return 'low';
    return 'ok';
  };
  el.innerHTML = data.map((b, i) => `
    <div class="risk-row" onclick="drillRisk(${i})">
      <div class="risk-indicator ${indicatorClass(b)}"></div>
      <div class="risk-info">
        <div class="risk-label">${b.riskBucket}</div>
        <div class="risk-meta">${num(b.uniqueDevices)} devices · ${num(b.uniqueIPs)} IPs</div>
      </div>
      <div class="risk-count">${num(b.hitCount)}</div>
    </div>
  `).join('');
}

// ─── Analytics: Live Feed (full, 30 hits) ───
function renderAnalyticsFeed(data) {
  const tbody = document.getElementById('a-feed-body');
  if (!data || !data.length) { tbody.innerHTML = '<tr><td colspan="9" style="color:var(--text-dim)">No recent hits</td></tr>'; return; }
  tbody.innerHTML = data.slice(0, 30).map((r, i) => {
    const t = r.threatLevel || 'OK';
    const badgeClass = t === 'HIGH' ? 'high' : t === 'MED' ? 'med' : t === 'LOW' ? 'low' : 'ok';
    const time = r.receivedAt ? new Date(r.receivedAt).toLocaleTimeString('en',{hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:false}) : '--';
    return `<tr onclick="drillHit(${i})">
      <td>${time}</td>
      <td>${r.ipAddress || '--'}</td>
      <td><span class="badge ${badgeClass}">${t}</span></td>
      <td>${r.botScore ?? '--'}</td>
      <td>${r.platform || '--'}</td>
      <td>${r.browser || '--'}</td>
      <td>${r.resolution || '--'}</td>
      <td style="color:var(--cyan)">${r.fP_Short || '--'}</td>
      <td style="max-width:200px;color:var(--text-dim)">${r.botSignalsList || ''}</td>
    </tr>`;
  }).join('');
}

// ─── Analytics: Signals ───
function renderSignals(data) {
  const el = document.getElementById('signal-list');
  if (!data || !data.length) { el.innerHTML = '<div style="color:var(--text-dim)">No signals</div>'; return; }
  const maxCount = Math.max(...data.map(s => s.timesTriggered || 1));
  el.innerHTML = data.slice(0, 12).map((s, i) => {
    const pct = ((s.timesTriggered || 0) / maxCount * 100).toFixed(0);
    return `<div class="signal-row" onclick="drillSignal(${i})">
      <div class="signal-name" title="${s.signal}">${s.signal}</div>
      <div class="signal-bar-track"><div class="signal-bar-fill" style="width:${pct}%"></div></div>
      <div class="signal-count">${num(s.timesTriggered)}</div>
    </div>`;
  }).join('');
}

// ─── Analytics: Evasion ───
function renderEvasion(data) {
  const el = document.getElementById('evasion-grid');
  if (!data) { el.innerHTML = '<div>No data</div>'; return; }
  const items = [
    ['CANVAS', data.canvasEvasion], ['WEBGL', data.webGLEvasion],
    ['AUDIO NOISE', data.audioNoise], ['FONT SPOOF', data.fontSpoof],
    ['STEALTH', data.stealthDetected], ['EVASION TOOLS', data.evasionToolsFound],
    ['PROXY BLOCK', data.proxyBlocked], ['EVASION V2', data.evasionV2Signals],
    ['DNT ENABLED', data.dnT_Enabled],
  ];
  el.innerHTML = items.map(([label, val]) => {
    const v = val || 0;
    return `<div class="evasion-card"><div class="evasion-val ${v > 0 ? 'alert' : ''}">${num(v)}</div><div class="evasion-lbl">${label}</div></div>`;
  }).join('');
}

// ─── Analytics: Behavior ───
function renderBehavior(data) {
  const el = document.getElementById('behavior-compare');
  if (!data || !data.length) { el.innerHTML = '<div>No data</div>'; return; }
  const human = data.find(d => d.classification && d.classification.includes('<50'));
  const bot = data.find(d => d.classification && d.classification.includes('50'));
  const stat = (label, hv) => `<div class="behavior-stat"><span>${label}</span><span class="val">${hv??'--'}</span></div>`;
  const col = (title, cls, d) => `
    <div class="behavior-col">
      <div class="behavior-col-title ${cls}">${title}</div>
      ${stat('Hits', num(d?.hitCount))}
      ${stat('Avg Mouse Moves', (d?.avgMouseMoves||0).toFixed(0))}
      ${stat('Avg Entropy', (d?.avgMouseEntropy||0).toFixed(0))}
      ${stat('No Mouse', num(d?.noMouseHits))}
      ${stat('Zero Entropy', num(d?.zeroEntropyHits))}
      ${stat('Scrolled', num(d?.scrolledHits))}
      ${stat('Contradictions', num(d?.scrollContradictions))}
      ${stat('Flagged', num(d?.flaggedHits))}
    </div>
  `;
  el.innerHTML = col('HUMAN', 'human', human) + col('BOT', 'bot', bot);
}

// ─── Analytics: Fingerprints ───
function renderFingerprints(data) {
  const el = document.getElementById('fp-clusters');
  if (!data || !data.length) { el.innerHTML = '<div style="color:var(--text-dim)">No clusters</div>'; return; }
  el.innerHTML = data.slice(0, 10).map((fp, i) => {
    const hash = (fp.canvasFingerprint || '--').substring(0, 12);
    const score = fp.avgBotScore != null ? fp.avgBotScore.toFixed(0) : '--';
    const scoreColor = score >= 50 ? 'var(--red)' : score >= 20 ? 'var(--yellow)' : 'var(--green)';
    return `<div class="fp-row" onclick="drillFP(${i})">
      <div class="fp-hash">${hash}</div>
      <div class="fp-meta">${num(fp.uniqueIPs)} IPs · ${fp.primaryPlatform||'?'} · <span style="color:${scoreColor}">score ${score}</span></div>
      <div class="fp-hits">${num(fp.hitCount)}</div>
    </div>`;
  }).join('');
}

// ─── Analytics: Devices ───
function renderDevices(data) {
  const el = document.getElementById('device-breakdown');
  if (!data || !data.length) { el.innerHTML = '<div style="color:var(--text-dim)">No data</div>'; return; }
  const byPlatform = {};
  data.forEach(d => {
    const p = d.platform || 'Unknown';
    if (!byPlatform[p]) byPlatform[p] = { hits: 0, devices: 0, browsers: new Set() };
    byPlatform[p].hits += d.hitCount || 0;
    byPlatform[p].devices += d.uniqueDevices || 0;
    if (d.browser) byPlatform[p].browsers.add(d.browser);
  });
  const maxHits = Math.max(...Object.values(byPlatform).map(v => v.hits || 1));
  el.innerHTML = '<div class="signal-list">' + Object.entries(byPlatform)
    .sort((a, b) => b[1].hits - a[1].hits)
    .slice(0, 10)
    .map(([platform, info]) => {
      const pct = (info.hits / maxHits * 100).toFixed(0);
      return `<div class="signal-row">
        <div class="signal-name">${platform}</div>
        <div class="signal-bar-track"><div class="signal-bar-fill" style="width:${pct}%"></div></div>
        <div class="signal-count">${num(info.hits)}</div>
      </div>`;
    }).join('') + '</div>';
}

// ============================================================================
// REFRESH LOOP — Only active view fetches & renders
// ============================================================================
// ============================================================================
// STAGGERED API ORCHESTRA — Sequential calls, progressive rendering, grid orbs
// Each API call fires in sequence. On completion its data renders immediately
// and a named Tron light-cycle orb spawns on the grid background.
// ============================================================================
const REFRESH_INTERVAL = 10;
let countdown = REFRESH_INTERVAL;

// Ops view: 3 sequential calls
const OPS_STEPS = [
  { name: 'HEALTH', contestant: 'TRON', fn: API.health, key: 'health',
    render() {
      const h = lastData.health;
      if (h) document.getElementById('etl-status').textContent = h.etL_Watermark ? `#${num(h.etL_Watermark)}` : '--';
    }},
  { name: 'INFRA', contestant: 'CLU', fn: API.infra, key: 'infra',
    render() {
      const { health, infra } = lastData;
      renderCriticalZone(buildIssues(health, infra));
      renderStatusStrip(health, infra);
      renderPipeline(health, infra);
      renderErrorLog(infra);
      renderOpsETL(health, infra);
      renderPipelineTables(infra);
      renderInfraDetail(infra);
      updateOpsBeacon(health, infra);
    }},
  { name: 'FEED', contestant: 'QUORRA', fn: API.recent, key: 'recent',
    render() { renderOpsFeed(lastData.recent); }},
];

// Analytics view: 10 sequential calls — each section pops in as data arrives
const ANALYTICS_STEPS = [
  { name: 'HEALTH', contestant: 'TRON', fn: API.health, key: 'health',
    render() { renderAnalyticsHero(lastData.health); updateAnalyticsBeacon(lastData.health); }},
  { name: 'INFRA', contestant: 'CLU', fn: API.infra, key: 'infra',
    render() { renderAnalyticsHero(lastData.health); renderAnalyticsETL(lastData.health); }},
  { name: 'HOURLY', contestant: 'GEM', fn: () => API.hourly(48), key: 'hourly',
    render() { renderHourlyChart(lastData.hourly); }},
  { name: 'BOTS', contestant: 'RINZLER', fn: API.bots, key: 'bots',
    render() { renderRiskList(lastData.bots); }},
  { name: 'SIGNALS', contestant: 'SARK', fn: API.signals, key: 'signals',
    render() { renderSignals(lastData.signals); }},
  { name: 'EVASION', contestant: 'CASTOR', fn: API.evasion, key: 'evasion',
    render() { renderEvasion(lastData.evasion); }},
  { name: 'BEHAVIOR', contestant: 'YORI', fn: API.behavior, key: 'behavior',
    render() { renderBehavior(lastData.behavior); }},
  { name: 'FEED', contestant: 'QUORRA', fn: API.recent, key: 'recent',
    render() { renderAnalyticsFeed(lastData.recent); }},
  { name: 'FP', contestant: 'RAM', fn: API.fingerprints, key: 'fingerprints',
    render() { renderFingerprints(lastData.fingerprints); }},
  { name: 'DEVICES', contestant: 'FLYNN', fn: API.devices, key: 'devices',
    render() { renderDevices(lastData.devices); }},
];

async function runPipeline(steps) {
  isRefreshing = true;
  refreshAbort = false;
  Grid.derezzAll();
  const countdownEl = document.getElementById('countdown');
  for (let i = 0; i < steps.length; i++) {
    if (refreshAbort) break;
    countdownEl.textContent = `${i + 1}/${steps.length}`;
    countdownEl.style.color = 'var(--cyan)';
    const step = steps[i];
    try {
      const data = await step.fn();
      if (refreshAbort) break;
      lastData[step.key] = data;
      Grid.spawnOrb(step.name, step.contestant);
      // Only render DOM when dashboard is visible (not on landing)
      if (currentView !== 'landing' && step.render) step.render();
    } catch (e) {
      console.warn(`Pipeline step ${step.name} failed:`, e);
    }
  }
  countdownEl.style.color = '';
  isRefreshing = false;
  countdown = REFRESH_INTERVAL;
  countdownEl.textContent = countdown;
}

async function refreshAll() {
  if (isRefreshing) return;
  // Always run the pipeline — cycles track API health regardless of view.
  // On landing or ops, run the ops pipeline (health/infra/recent).
  // On analytics, run the full analytics pipeline.
  if (currentView === 'analytics') await runPipeline(ANALYTICS_STEPS);
  else await runPipeline(OPS_STEPS);
}

setInterval(() => {
  document.getElementById('utc-clock').textContent = new Date().toISOString().substring(11, 19);
  if (!isRefreshing) {
    countdown--;
    document.getElementById('countdown').textContent = Math.max(0, countdown);
    if (countdown <= 0) refreshAll();
  }
}, 1000);

// Always start the pipeline — cycles race from the moment the page loads
refreshAll();
</script>

<!-- ════════════════════════════════════════════════════════════════════════
     THREE.JS 3D TRON ARENA — PerspectiveCamera + Trail Walls + Bloom
     Full 3D scene: overhead perspective camera, 3D cycle meshes with
     cone noses, vertical trail wall geometry (the iconic Tron light ribbons),
     ground glow pools, fog, directional lighting, slow camera drift.
     Replaces the Canvas 2D Grid stub above when module loads.
     ════════════════════════════════════════════════════════════════════════ -->
<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

(function () {
  'use strict';

  // ── Config ──────────────────────────────────────────────────────────────
  const CELL = 50;             // grid cell size in world units
  const ARENA_X = 1400;        // arena width  (X axis)
  const ARENA_Z = 900;         // arena depth  (Z axis)
  const HALF_X = ARENA_X / 2;
  const HALF_Z = ARENA_Z / 2;
  const WALL_H = 24;           // trail wall height (vertical ribbons)
  const MAX_TRAIL = 300;       // trail points per cycle
  const AMBIENT_MAX = 6;       // more ambient traffic — RTX 4090

  // ── Contestant Palette (Tron Grid Players) ─────────────────────────────
  const COLORS = {
    TRON:    0x00f3ff,   // Cyan — the hero
    CLU:     0xffaa00,   // Amber/Gold — the tyrant
    RINZLER: 0xff4400,   // Orange-Red — the enforcer
    QUORRA:  0xcc44ff,   // Purple — the ISO
    GEM:     0x88ddff,   // Ice Blue — the siren
    SARK:    0xff0044,   // Red — the commander
    CASTOR:  0xff00ff,   // Magenta — the wildcard
    YORI:    0x00ff88,   // Green — the architect
    RAM:     0xff66aa,   // Pink — the believer
    FLYNN:   0x4488ff,   // Blue — the creator
  };
  const AMBIENT_HEX = 0x006677;

  // ══════════════════════════════════════════════════════════════════════
  //  RENDERER + SCENE — Dark background, atmospheric fog
  // ══════════════════════════════════════════════════════════════════════
  const canvas = document.getElementById('grid-canvas');
  let W = window.innerWidth, H = window.innerHeight;

  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);  // no cap — RTX 4090
  renderer.setSize(W, H);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  renderer.setClearColor(0x000308, 1);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000308, 0.00025);

  // ══════════════════════════════════════════════════════════════════════
  //  PERSPECTIVE CAMERA — Overhead angle looking down at the arena
  // ══════════════════════════════════════════════════════════════════════
  const camera = new THREE.PerspectiveCamera(55, W / H, 1, 6000);
  camera.position.set(0, 750, 600);
  camera.lookAt(0, 0, -50);

  // ══════════════════════════════════════════════════════════════════════
  //  LIGHTING — Subtle directional + ambient for surface definition
  // ══════════════════════════════════════════════════════════════════════
  scene.add(new THREE.AmbientLight(0x112244, 0.3));
  const dirLight = new THREE.DirectionalLight(0x446688, 0.4);
  dirLight.position.set(200, 500, 300);
  scene.add(dirLight);

  // ══════════════════════════════════════════════════════════════════════
  //  BLOOM POST-PROCESSING — Only bright/emissive objects glow
  // ══════════════════════════════════════════════════════════════════════
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  const bloom = new UnrealBloomPass(
    new THREE.Vector2(W, H),
    1.8,   // strength — intense halos (RTX 4090)
    0.9,   // radius — wide cinematic spread
    0.25   // threshold — more objects participate in bloom
  );
  composer.addPass(bloom);
  composer.addPass(new OutputPass());

  // ══════════════════════════════════════════════════════════════════════
  //  GROUND GRID — Extended grid fading into fog + brighter arena grid
  // ══════════════════════════════════════════════════════════════════════
  const extGrid = new THREE.GridHelper(4000, 80, 0x003040, 0x001525);
  extGrid.material.transparent = true;
  extGrid.material.opacity = 0.6;
  scene.add(extGrid);

  // Arena interior grid (brighter)
  function buildArenaGrid() {
    const pts = [];
    for (let x = -HALF_X; x <= HALF_X; x += CELL) {
      pts.push(new THREE.Vector3(x, 0.1, -HALF_Z));
      pts.push(new THREE.Vector3(x, 0.1, HALF_Z));
    }
    for (let z = -HALF_Z; z <= HALF_Z; z += CELL) {
      pts.push(new THREE.Vector3(-HALF_X, 0.1, z));
      pts.push(new THREE.Vector3(HALF_X, 0.1, z));
    }
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    return new THREE.LineSegments(geo,
      new THREE.LineBasicMaterial({ color: 0x004858, transparent: true, opacity: 0.7 })
    );
  }
  scene.add(buildArenaGrid());

  // Arena border — bright, feeds bloom
  (function () {
    const y = 0.2;
    const pts = [
      new THREE.Vector3(-HALF_X, y, -HALF_Z),
      new THREE.Vector3( HALF_X, y, -HALF_Z),
      new THREE.Vector3( HALF_X, y,  HALF_Z),
      new THREE.Vector3(-HALF_X, y,  HALF_Z),
      new THREE.Vector3(-HALF_X, y, -HALF_Z),
    ];
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    scene.add(new THREE.Line(geo,
      new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.8 })
    ));
  })();

  // Arena border — vertical corner posts + top edge
  (function () {
    const corners = [
      [-HALF_X, -HALF_Z], [HALF_X, -HALF_Z],
      [HALF_X, HALF_Z], [-HALF_X, HALF_Z]
    ];
    for (let i = 0; i < 4; i++) {
      const [x1, z1] = corners[i];
      const [x2, z2] = corners[(i + 1) % 4];
      // Top edge
      const tGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(x1, WALL_H, z1),
        new THREE.Vector3(x2, WALL_H, z2)
      ]);
      scene.add(new THREE.Line(tGeo,
        new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.25 })
      ));
      // Vertical post at corner
      const vGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(x1, 0, z1),
        new THREE.Vector3(x1, WALL_H * 1.5, z1)
      ]);
      scene.add(new THREE.Line(vGeo,
        new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.5 })
      ));
    }
  })();

  // ══════════════════════════════════════════════════════════════════════
  //  CORNER LIGHT PILLARS — Dramatic vertical beams at arena corners
  // ══════════════════════════════════════════════════════════════════════
  (function () {
    const beamH = WALL_H * 6;
    const beamGeo = new THREE.PlaneGeometry(4, beamH);
    const beamMat = new THREE.MeshBasicMaterial({
      color: 0x00f3ff, transparent: true, opacity: 0.12,
      blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false
    });
    const corners = [
      [-HALF_X, -HALF_Z], [HALF_X, -HALF_Z],
      [HALF_X, HALF_Z], [-HALF_X, HALF_Z]
    ];
    corners.forEach(([x, z]) => {
      const b1 = new THREE.Mesh(beamGeo, beamMat);
      b1.position.set(x, beamH / 2, z);
      scene.add(b1);
      const b2 = b1.clone();
      b2.rotation.y = Math.PI / 2;
      scene.add(b2);
    });
  })();

  // ══════════════════════════════════════════════════════════════════════
  //  ARENA FLOOR GLOW — Subtle illuminated playing field
  // ══════════════════════════════════════════════════════════════════════
  (function () {
    const floorGeo = new THREE.PlaneGeometry(ARENA_X, ARENA_Z);
    const floorMat = new THREE.MeshBasicMaterial({
      color: 0x001520, transparent: true, opacity: 0.35,
      side: THREE.DoubleSide
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.1;
    scene.add(floor);
  })();

  // ══════════════════════════════════════════════════════════════════════
  //  ARENA CENTER MARKER — Hexagonal reticle on the arena floor
  // ══════════════════════════════════════════════════════════════════════
  (function () {
    const addMat = new THREE.MeshBasicMaterial({
      color: 0x00f3ff, transparent: true, opacity: 0.15,
      side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthWrite: false
    });
    const ring = new THREE.Mesh(new THREE.RingGeometry(18, 22, 6), addMat);
    ring.rotation.x = -Math.PI / 2;
    ring.position.y = 0.3;
    scene.add(ring);
    const dot = new THREE.Mesh(
      new THREE.CircleGeometry(6, 16),
      addMat.clone()
    );
    dot.material.opacity = 0.2;
    dot.rotation.x = -Math.PI / 2;
    dot.position.y = 0.3;
    scene.add(dot);
  })();

  // ══════════════════════════════════════════════════════════════════════
  //  HELPERS
  // ══════════════════════════════════════════════════════════════════════
  const snap = v => Math.round(v / CELL) * CELL;

  // Glow texture cache (radial gradient for sprites/planes)
  const glowCache = {};
  function getGlowTexture(hex) {
    if (glowCache[hex]) return glowCache[hex];
    const sz = 64, c = document.createElement('canvas');
    c.width = sz; c.height = sz;
    const ctx = c.getContext('2d');
    const col = new THREE.Color(hex);
    const r = Math.round(col.r * 255), g = Math.round(col.g * 255), b = Math.round(col.b * 255);
    const grad = ctx.createRadialGradient(sz/2,sz/2,0, sz/2,sz/2,sz/2);
    grad.addColorStop(0, `rgba(${r},${g},${b},1)`);
    grad.addColorStop(0.3, `rgba(${r},${g},${b},0.3)`);
    grad.addColorStop(1, `rgba(${r},${g},${b},0)`);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, sz, sz);
    const tex = new THREE.CanvasTexture(c);
    glowCache[hex] = tex;
    return tex;
  }

  // Label texture
  function makeLabelTexture(stepName, contestantName, hex) {
    const c = document.createElement('canvas');
    c.width = 256; c.height = 48;
    const ctx = c.getContext('2d');
    const col = new THREE.Color(hex);
    const r = Math.round(col.r * 255), g = Math.round(col.g * 255), b = Math.round(col.b * 255);
    ctx.font = 'bold 18px "Share Tech Mono", monospace';
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillText(`${contestantName} // ${stepName}`, 4, 20);
    ctx.font = '12px "Share Tech Mono", monospace';
    ctx.fillStyle = `rgba(${r},${g},${b},0.5)`;
    ctx.fillText('\u25A0 ONLINE', 4, 38);
    return new THREE.CanvasTexture(c);
  }

  // ══════════════════════════════════════════════════════════════════════
  //  3D CYCLE MESH — Box body + cone nose + cockpit accent + ground glow
  // ══════════════════════════════════════════════════════════════════════
  function buildCycleMesh(hex, isAmbient) {
    const grp = new THREE.Group();
    const s = isAmbient ? 0.8 : 1.3;
    const bw = 28 * s, bh = 8 * s, bd = 12 * s;

    // Main body — sits on the grid
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(bw, bh, bd),
      new THREE.MeshBasicMaterial({ color: hex })
    );
    body.position.y = bh / 2;
    grp.add(body);

    // Cockpit accent (white-hot, blooms hard)
    if (!isAmbient) {
      const cockpit = new THREE.Mesh(
        new THREE.BoxGeometry(14 * s, 5 * s, 8 * s),
        new THREE.MeshBasicMaterial({ color: 0xffffff })
      );
      cockpit.position.set(2 * s, bh + 2 * s, 0);
      grp.add(cockpit);
    }

    // Nose wedge (cone rotated to point forward along +X)
    const noseGeo = new THREE.ConeGeometry(6 * s, 18 * s, 4);
    noseGeo.rotateZ(-Math.PI / 2);
    const nose = new THREE.Mesh(noseGeo,
      new THREE.MeshBasicMaterial({ color: hex })
    );
    nose.position.set(bw / 2 + 7 * s, bh / 2, 0);
    grp.add(nose);

    // Identity disc ring (contestants only)
    if (!isAmbient) {
      const disc = new THREE.Mesh(
        new THREE.TorusGeometry(20 * s, 0.5, 8, 32),
        new THREE.MeshBasicMaterial({ color: hex, wireframe: true, transparent: true, opacity: 0.3 })
      );
      disc.rotation.x = Math.PI * 0.5;
      disc.position.y = bh / 2;
      disc.name = 'disc';
      grp.add(disc);
    }

    // Ground glow pool (flat plane on the floor, additive)
    const glowPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(isAmbient ? 60 : 120, isAmbient ? 60 : 120),
      new THREE.MeshBasicMaterial({
        map: getGlowTexture(hex), transparent: true,
        blending: THREE.AdditiveBlending, depthWrite: false,
        side: THREE.DoubleSide
      })
    );
    glowPlane.rotation.x = -Math.PI / 2;
    glowPlane.position.y = 0.5;
    grp.add(glowPlane);

    return grp;
  }

  // ══════════════════════════════════════════════════════════════════════
  //  TRAIL WALL — Custom GLSL ShaderMaterial (the iconic Tron light walls)
  //  Animated energy flow, fresnel edge glow, pulse waves, scanlines,
  //  top-edge corona, trail-length fade. All fed through bloom.
  // ══════════════════════════════════════════════════════════════════════

  // ── Shared shader source (compiled once, instanced per cycle) ──────
  const TRAIL_VERT = /* glsl */`
    varying vec2 vUv;
    varying vec3 vWorldPos;
    void main() {
      vUv = uv;
      vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;

  const TRAIL_FRAG = /* glsl */`
    uniform float uTime;
    uniform vec3  uColor;
    uniform float uOpacity;

    varying vec2 vUv;
    varying vec3 vWorldPos;

    // ── Pseudo-random hash (cheap noise) ───────────────────────────────
    float hash(float n) { return fract(sin(n) * 43758.5453); }

    void main() {
      float u = vUv.x;   // 0 = oldest trail point → 1 = cycle head
      float v = vUv.y;   // 0 = ground → 1 = top edge

      // ── Trail age fade: old segments go transparent ──────────────────
      float trailFade = smoothstep(0.0, 0.15, u);

      // ── Vertical energy flow (scrolling upward through the wall) ─────
      float flowSpeed = 3.0;
      float flowFreq  = 12.0;
      float flow = sin((v * flowFreq - uTime * flowSpeed) * 6.2832);
      flow = pow(clamp(flow, 0.0, 1.0), 4.0);  // sharpen into thin bright lines

      // ── Horizontal pulse waves racing toward the cycle head ──────────
      float pulseSpeed = 6.0;
      float pulseFreq  = 8.0;
      float pulse = sin((u * pulseFreq - uTime * pulseSpeed) * 6.2832);
      pulse = pow(clamp(pulse, 0.0, 1.0), 10.0);  // ultra-thin bright streaks

      // ── Top-edge corona (bright bloom band at the ribbon crest) ──────
      float topGlow = pow(v, 3.0) * 1.2;

      // ── Ground-bleed glow (light spilling onto the floor) ────────────
      float bottomGlow = pow(1.0 - v, 5.0) * 0.25;

      // ── Fresnel edge glow (screen-space normal approximation) ────────
      vec3 dFdxPos = dFdx(vWorldPos);
      vec3 dFdyPos = dFdy(vWorldPos);
      vec3 faceN   = normalize(cross(dFdxPos, dFdyPos));
      vec3 viewDir = normalize(cameraPosition - vWorldPos);
      float fresnel = 1.0 - abs(dot(faceN, viewDir));
      fresnel = pow(fresnel, 2.5) * 0.6;

      // ── Scanline interference (horizontal CRT-like lines) ────────────
      float scanFreq = 60.0;
      float scan = sin(v * scanFreq * 6.2832) * 0.5 + 0.5;
      scan = 0.82 + scan * 0.18;    // subtle, not overpowering

      // ── Micro-circuit pattern (faint grid texture within the wall) ────
      float circuitH = step(0.97, fract(v * 20.0)) * 0.15;
      float circuitV = step(0.97, fract(u * 40.0)) * 0.10;
      float circuit  = circuitH + circuitV;

      // ── Head proximity flare (bright glow near the cycle) ────────────
      float headFlare = pow(u, 12.0) * 0.8;

      // ── Combine all energy ───────────────────────────────────────────
      float energy = flow      * 0.30
                   + pulse     * 0.25
                   + topGlow   * 0.15
                   + bottomGlow
                   + fresnel
                   + circuit
                   + headFlare;

      float alpha = (0.25 + energy * 0.75) * trailFade * uOpacity;

      // ── Color with HDR energy boost (drives bloom) ───────────────────
      vec3 col = uColor * (1.0 + energy * 2.5);

      // Apply scanline modulation
      col *= scan;

      // ── Hot-white core at the very top edge ──────────────────────────
      float edgeWhite = pow(v, 8.0) * 0.4;
      col = mix(col, vec3(1.0), edgeWhite);

      gl_FragColor = vec4(col, clamp(alpha, 0.0, 1.0));
    }
  `;

  // Shared uniform clock — updated once per frame, all trail materials read it
  const trailClock = { value: 0 };

  function buildTrail(hex) {
    const MAX = MAX_TRAIL;
    const col = new THREE.Color(hex);

    // ── Wall mesh: indexed BufferGeometry, 2 verts per point (bottom+top) ──
    const wallPos = new Float32Array(MAX * 2 * 3);
    const wallUV  = new Float32Array(MAX * 2 * 2);   // new: UV coords
    const wallGeo = new THREE.BufferGeometry();
    wallGeo.setAttribute('position', new THREE.BufferAttribute(wallPos, 3));
    wallGeo.setAttribute('uv',       new THREE.BufferAttribute(wallUV, 2));

    const indices = [];
    for (let i = 0; i < MAX - 1; i++) {
      const b0 = i * 2, t0 = i * 2 + 1;
      const b1 = (i + 1) * 2, t1 = (i + 1) * 2 + 1;
      indices.push(b0, b1, t1, b0, t1, t0);
    }
    wallGeo.setIndex(indices);
    wallGeo.setDrawRange(0, 0);

    const wallMat = new THREE.ShaderMaterial({
      vertexShader:   TRAIL_VERT,
      fragmentShader: TRAIL_FRAG,
      uniforms: {
        uTime:    trailClock,
        uColor:   { value: new THREE.Vector3(col.r, col.g, col.b) },
        uOpacity: { value: 0.65 }
      },
      transparent: true,
      side: THREE.DoubleSide,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const wallMesh = new THREE.Mesh(wallGeo, wallMat);
    wallMesh.frustumCulled = false;

    // ── Top edge line (bright, feeds bloom — the glowing ribbon crest) ──
    const topPos = new Float32Array(MAX * 3);
    const topGeo = new THREE.BufferGeometry();
    topGeo.setAttribute('position', new THREE.BufferAttribute(topPos, 3));
    topGeo.setDrawRange(0, 0);
    const topLine = new THREE.Line(topGeo,
      new THREE.LineBasicMaterial({ color: hex, transparent: true, opacity: 0.95 })
    );
    topLine.frustumCulled = false;

    // ── Base glow line (on the floor, additive bloom feeder) ────────────
    const basePos = new Float32Array(MAX * 3);
    const baseGeo = new THREE.BufferGeometry();
    baseGeo.setAttribute('position', new THREE.BufferAttribute(basePos, 3));
    baseGeo.setDrawRange(0, 0);
    const baseLine = new THREE.Line(baseGeo,
      new THREE.LineBasicMaterial({
        color: hex, transparent: true, opacity: 0.5,
        blending: THREE.AdditiveBlending
      })
    );
    baseLine.frustumCulled = false;

    return { wallPos, wallUV, wallGeo, wallMesh, wallMat,
             topPos, topGeo, topLine, basePos, baseGeo, baseLine };
  }

  // ══════════════════════════════════════════════════════════════════════
  //  CYCLE POOL + SPAWN
  // ══════════════════════════════════════════════════════════════════════
  const cycles = [];

  function spawnCycle(stepName, contestant, isAmbient) {
    const hex = isAmbient ? AMBIENT_HEX : (COLORS[contestant] || 0x00f3ff);
    const speed = isAmbient ? (1.5 + Math.random()) : (1.2 + Math.random() * 0.6);

    // Random grid position inside arena (X/Z plane)
    let x = snap(-HALF_X + CELL + Math.random() * (ARENA_X - 2 * CELL));
    let z = snap(-HALF_Z + CELL + Math.random() * (ARENA_Z - 2 * CELL));
    x = Math.max(-HALF_X + CELL, Math.min(HALF_X - CELL, x));
    z = Math.max(-HALF_Z + CELL, Math.min(HALF_Z - CELL, z));

    // Random cardinal direction
    const dirs = [[speed,0],[-speed,0],[0,speed],[0,-speed]];
    const [dx, dz] = dirs[Math.floor(Math.random() * 4)];

    const mesh = buildCycleMesh(hex, isAmbient);
    mesh.position.set(x, 0, z);
    mesh.rotation.y = Math.atan2(-dz, dx);  // face direction of travel
    scene.add(mesh);

    // Label sprite (floats above the cycle)
    let label = null;
    if (!isAmbient && stepName) {
      const tex = makeLabelTexture(stepName, contestant, hex);
      label = new THREE.Sprite(
        new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false })
      );
      label.scale.set(80, 15, 1);
      label.position.set(0, 32, 0);
      mesh.add(label);
    }

    const trail = buildTrail(hex);
    scene.add(trail.wallMesh);
    scene.add(trail.topLine);
    scene.add(trail.baseLine);

    // ── Headlight glow cone (volumetric forward beam) ──────────────────
    let headlight = null;
    if (!isAmbient) {
      const hlGeo = new THREE.ConeGeometry(40, 120, 16, 1, true);
      hlGeo.rotateZ(-Math.PI / 2);  // point along +X (forward)
      hlGeo.translate(60, 0, 0);    // offset forward from cycle center
      const hlMat = new THREE.MeshBasicMaterial({
        color: hex, transparent: true, opacity: 0.06,
        blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false
      });
      headlight = new THREE.Mesh(hlGeo, hlMat);
      headlight.position.set(x, WALL_H * 0.3, z);
      headlight.rotation.y = Math.atan2(-dz, dx);
      scene.add(headlight);
    }

    cycles.push({
      stepName, contestant, hex, mesh, trail, label, headlight,
      x, z, dx, dz, speed,
      life: 1, maxLife: isAmbient ? 30000 : 20000,
      born: performance.now(),
      pts: [], turnCD: 0, ambient: isAmbient, derezz: false
    });
    if (!isAmbient) emitPulse(x, z, hex);
  }

  // ══════════════════════════════════════════════════════════════════════
  //  POOLED PARTICLE SYSTEM — 3D particles with gravity
  // ══════════════════════════════════════════════════════════════════════
  const P_MAX = 2000;
  const pPos = new Float32Array(P_MAX * 3);
  const pCol = new Float32Array(P_MAX * 3);
  const pGeo = new THREE.BufferGeometry();
  pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
  pGeo.setAttribute('color', new THREE.BufferAttribute(pCol, 3));
  const pMesh = new THREE.Points(pGeo, new THREE.PointsMaterial({
    size: 5, vertexColors: true, transparent: true,
    blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true
  }));
  pMesh.frustumCulled = false;
  scene.add(pMesh);

  const pPool = [];
  function emit(x, z, vx, vz, hex) {
    if (pPool.length >= P_MAX) return;
    const col = new THREE.Color(hex);
    pPool.push({
      x, y: WALL_H * 0.5, z,
      vx, vy: 1 + Math.random() * 4, vz,  // fly upward
      r: col.r, g: col.g, b: col.b,
      life: 1, decay: 0.015 + Math.random() * 0.02
    });
  }

  function updateParticles() {
    for (let i = pPool.length - 1; i >= 0; i--) {
      const p = pPool[i];
      p.x += p.vx; p.y += p.vy; p.z += p.vz;
      p.vx *= 0.96; p.vy -= 0.06; p.vz *= 0.96;  // gravity
      p.life -= p.decay;
      if (p.life <= 0 || p.y < 0) pPool.splice(i, 1);
    }
    const len = pPool.length;
    for (let i = 0; i < P_MAX; i++) {
      if (i < len) {
        const p = pPool[i];
        pPos[i*3] = p.x; pPos[i*3+1] = Math.max(0, p.y); pPos[i*3+2] = p.z;
        pCol[i*3] = p.r * p.life; pCol[i*3+1] = p.g * p.life; pCol[i*3+2] = p.b * p.life;
      } else {
        pPos[i*3+1] = -9999;
        pCol[i*3] = pCol[i*3+1] = pCol[i*3+2] = 0;
      }
    }
    pGeo.attributes.position.needsUpdate = true;
    pGeo.attributes.color.needsUpdate = true;
  }

  // ══════════════════════════════════════════════════════════════════════
  //  DEREZZ + CLEANUP
  // ══════════════════════════════════════════════════════════════════════
  function derezzAll() {
    for (const c of cycles) {
      if (!c.ambient && c.life > 0 && !c.derezz) {
        c.derezz = true;
        for (let i = 0; i < 60; i++) {
          const a = (i / 60) * Math.PI * 2;
          const sp = 2 + Math.random() * 7;
          emit(c.x, c.z, Math.cos(a) * sp, Math.sin(a) * sp, c.hex);
        }
      }
    }
  }

  function removeCycle(i) {
    const c = cycles[i];
    scene.remove(c.mesh);
    scene.remove(c.trail.wallMesh);
    scene.remove(c.trail.topLine);
    scene.remove(c.trail.baseLine);
    if (c.headlight) scene.remove(c.headlight);
    c.mesh.traverse(o => {
      if (o.geometry) o.geometry.dispose();
      if (o.material) {
        if (o.material.map) o.material.map.dispose();
        o.material.dispose();
      }
    });
    c.trail.wallGeo.dispose(); c.trail.wallMat.dispose();
    c.trail.topGeo.dispose();  c.trail.topLine.material.dispose();
    c.trail.baseGeo.dispose(); c.trail.baseLine.material.dispose();
    if (c.headlight) { c.headlight.geometry?.dispose(); c.headlight.material?.dispose(); }
    cycles.splice(i, 1);
  }

  // ══════════════════════════════════════════════════════════════════════
  //  FLOATING DATA MOTES — Atmospheric luminous particles across arena
  // ══════════════════════════════════════════════════════════════════════
  const MOTE_COUNT = 150;
  const motePos = new Float32Array(MOTE_COUNT * 3);
  const moteCol = new Float32Array(MOTE_COUNT * 3);
  const moteVel = [];
  for (let i = 0; i < MOTE_COUNT; i++) {
    motePos[i * 3]     = (Math.random() - 0.5) * ARENA_X * 1.2;
    motePos[i * 3 + 1] = 5 + Math.random() * WALL_H * 3;
    motePos[i * 3 + 2] = (Math.random() - 0.5) * ARENA_Z * 1.2;
    const brightness = 0.2 + Math.random() * 0.3;
    moteCol[i * 3]     = 0;
    moteCol[i * 3 + 1] = 0.95 * brightness;
    moteCol[i * 3 + 2] = 1.0 * brightness;
    moteVel.push({
      vx: (Math.random() - 0.5) * 0.3,
      vy: (Math.random() - 0.5) * 0.1,
      vz: (Math.random() - 0.5) * 0.3,
      phase: Math.random() * Math.PI * 2
    });
  }
  const moteGeo = new THREE.BufferGeometry();
  moteGeo.setAttribute('position', new THREE.BufferAttribute(motePos, 3));
  moteGeo.setAttribute('color', new THREE.BufferAttribute(moteCol, 3));
  const moteMesh = new THREE.Points(moteGeo, new THREE.PointsMaterial({
    size: 3, vertexColors: true, transparent: true, opacity: 0.6,
    blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true
  }));
  moteMesh.frustumCulled = false;
  scene.add(moteMesh);

  function updateMotes(now) {
    const t = now * 0.001;
    for (let i = 0; i < MOTE_COUNT; i++) {
      const v = moteVel[i];
      motePos[i * 3]     += v.vx + Math.sin(t * 0.5 + v.phase) * 0.05;
      motePos[i * 3 + 1] += v.vy + Math.cos(t * 0.3 + v.phase) * 0.02;
      motePos[i * 3 + 2] += v.vz + Math.cos(t * 0.4 + v.phase) * 0.05;
      if (motePos[i * 3]     >  HALF_X * 1.2) motePos[i * 3]     = -HALF_X * 1.2;
      if (motePos[i * 3]     < -HALF_X * 1.2) motePos[i * 3]     =  HALF_X * 1.2;
      if (motePos[i * 3 + 2] >  HALF_Z * 1.2) motePos[i * 3 + 2] = -HALF_Z * 1.2;
      if (motePos[i * 3 + 2] < -HALF_Z * 1.2) motePos[i * 3 + 2] =  HALF_Z * 1.2;
      if (motePos[i * 3 + 1] > WALL_H * 4)    motePos[i * 3 + 1] = 5;
      if (motePos[i * 3 + 1] < 2)              motePos[i * 3 + 1] = WALL_H * 3;
    }
    moteGeo.attributes.position.needsUpdate = true;
  }

  // ══════════════════════════════════════════════════════════════════════
  //  PULSE RINGS — Expanding ground rings on contestant spawn
  // ══════════════════════════════════════════════════════════════════════
  const pulseRings = [];

  function emitPulse(x, z, hex) {
    const geo = new THREE.RingGeometry(2, 5, 64);
    const mat = new THREE.MeshBasicMaterial({
      color: hex, transparent: true, opacity: 0.9,
      side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthWrite: false
    });
    const ring = new THREE.Mesh(geo, mat);
    ring.rotation.x = -Math.PI / 2;
    ring.position.set(x, 0.5, z);
    scene.add(ring);
    pulseRings.push({ mesh: ring, geo, mat, life: 1.0 });
  }

  function updatePulseRings() {
    for (let i = pulseRings.length - 1; i >= 0; i--) {
      const pr = pulseRings[i];
      pr.life -= 0.012;
      const scale = 1 + (1 - pr.life) * 40;
      pr.mesh.scale.set(scale, scale, 1);
      pr.mat.opacity = pr.life * 0.6;
      if (pr.life <= 0) {
        scene.remove(pr.mesh);
        pr.geo.dispose();
        pr.mat.dispose();
        pulseRings.splice(i, 1);
      }
    }
  }

  // ══════════════════════════════════════════════════════════════════════
  //  MAIN UPDATE LOOP
  // ══════════════════════════════════════════════════════════════════════
  function update(now) {
    for (let i = cycles.length - 1; i >= 0; i--) {
      const c = cycles[i];

      // Derezz animation
      if (c.derezz) {
        c.life -= 0.03;
        c.mesh.scale.setScalar(Math.max(0.01, c.life));
        // Fade trail walls during derezz (shader uniform)
        c.trail.wallMat.uniforms.uOpacity.value = 0.65 * c.life;
        c.trail.topLine.material.opacity = 0.95 * c.life;
        // Fade headlight
        if (c.headlight) c.headlight.material.opacity = 0.06 * c.life;
        if (c.life <= 0) { removeCycle(i); continue; }
        continue;
      }

      // Age out
      if (now - c.born > c.maxLife) {
        c.life -= 0.008;
        if (c.life <= 0) { removeCycle(i); continue; }
      }

      // Movement (X/Z plane)
      c.x += c.dx;
      c.z += c.dz;

      // ── Arena Wall Bounce ──
      let bounced = false;
      if (c.x <= -HALF_X) { c.x = -HALF_X; bounced = true; }
      if (c.x >=  HALF_X) { c.x =  HALF_X; bounced = true; }
      if (c.z <= -HALF_Z) { c.z = -HALF_Z; bounced = true; }
      if (c.z >=  HALF_Z) { c.z =  HALF_Z; bounced = true; }

      if (bounced) {
        if (Math.abs(c.dx) > 0.01) {
          c.dz = (Math.random() > 0.5 ? 1 : -1) * c.speed;
          c.dx = 0;
        } else {
          c.dx = (Math.random() > 0.5 ? 1 : -1) * c.speed;
          c.dz = 0;
        }
        c.turnCD = Math.ceil(CELL / c.speed) + 10;
        // Wall-impact spark burst (3D particles fly upward)
        for (let j = 0; j < 24; j++) {
          const a = Math.random() * Math.PI * 2;
          const sp = 2 + Math.random() * 4;
          emit(c.x, c.z, Math.cos(a) * sp, Math.sin(a) * sp, c.hex);
        }
      }

      // ── Grid Intersection Turns (Tron light-cycle behavior) ──
      c.turnCD--;
      const sp = Math.max(Math.abs(c.dx), Math.abs(c.dz)) + 0.5;
      const onX = Math.abs(c.x % CELL) < sp || Math.abs(c.x % CELL - CELL) < sp;
      const onZ = Math.abs(c.z % CELL) < sp || Math.abs(c.z % CELL - CELL) < sp;
      if (onX && onZ && c.turnCD <= 0 && Math.random() < (c.ambient ? 0.06 : 0.15)) {
        c.x = snap(c.x); c.z = snap(c.z);
        if (Math.abs(c.dx) > 0.01) {
          c.dz = (Math.random() > 0.5 ? 1 : -1) * c.speed;
          c.dx = 0;
        } else {
          c.dx = (Math.random() > 0.5 ? 1 : -1) * c.speed;
          c.dz = 0;
        }
        c.turnCD = Math.ceil(CELL / c.speed) + 5;
      }

      // Update mesh position + face direction of travel
      c.mesh.position.set(c.x, 0, c.z);
      if (Math.abs(c.dx) > 0.01 || Math.abs(c.dz) > 0.01) {
        const facing = Math.atan2(-c.dz, c.dx);
        c.mesh.rotation.y = facing;
        // Sync headlight cone with cycle position + heading
        if (c.headlight) {
          c.headlight.position.set(c.x, WALL_H * 0.3, c.z);
          c.headlight.rotation.y = facing;
        }
      }

      // Spin identity disc
      const disc = c.mesh.getObjectByName('disc');
      if (disc) disc.rotation.z += 0.03;

      // ── Trail Wall Update (positions + UVs for shader) ──
      c.pts.push([c.x, c.z]);
      if (c.pts.length > MAX_TRAIL) c.pts.shift();

      const t = c.trail;
      const n = c.pts.length;
      const nMinus1 = Math.max(n - 1, 1);
      for (let j = 0; j < n; j++) {
        const px = c.pts[j][0], pz = c.pts[j][1];
        const u = j / nMinus1;  // 0 = oldest → 1 = cycle head

        // Wall: bottom vertex (y=0) + top vertex (y=WALL_H)
        const bi = (j * 2) * 3, ti = (j * 2 + 1) * 3;
        t.wallPos[bi] = px;   t.wallPos[bi+1] = 0;       t.wallPos[bi+2] = pz;
        t.wallPos[ti] = px;   t.wallPos[ti+1] = WALL_H;  t.wallPos[ti+2] = pz;

        // UVs: bottom (u, 0), top (u, 1)
        const bUV = (j * 2) * 2, tUV = (j * 2 + 1) * 2;
        t.wallUV[bUV] = u;   t.wallUV[bUV+1] = 0;
        t.wallUV[tUV] = u;   t.wallUV[tUV+1] = 1;

        // Top edge line
        t.topPos[j*3] = px;   t.topPos[j*3+1] = WALL_H;  t.topPos[j*3+2] = pz;
        // Base glow line
        t.basePos[j*3] = px;  t.basePos[j*3+1] = 0.2;    t.basePos[j*3+2] = pz;
      }
      t.wallGeo.setDrawRange(0, Math.max(0, (n - 1) * 6));
      t.wallGeo.attributes.position.needsUpdate = true;
      t.wallGeo.attributes.uv.needsUpdate = true;
      t.topGeo.setDrawRange(0, n);
      t.topGeo.attributes.position.needsUpdate = true;
      t.baseGeo.setDrawRange(0, n);
      t.baseGeo.attributes.position.needsUpdate = true;

      // Fade shader opacity + lines with life
      t.wallMat.uniforms.uOpacity.value = (c.ambient ? 0.30 : 0.65) * c.life;
      t.topLine.material.opacity = (c.ambient ? 0.5 : 0.95) * c.life;
      t.baseLine.material.opacity = (c.ambient ? 0.25 : 0.5) * c.life;

      // ── Continuous head-spark emission (particles trail behind the cycle) ──
      if (!c.derezz && Math.random() < (c.ambient ? 0.15 : 0.5)) {
        const sparkSpread = 2;
        const svx = -c.dx * 0.5 + (Math.random() - 0.5) * sparkSpread;
        const svz = -c.dz * 0.5 + (Math.random() - 0.5) * sparkSpread;
        emit(c.x, c.z, svx, svz, c.hex);
      }
    }

    // ── Update shader clock for all trail walls ──
    trailClock.value = now * 0.001;

    updateParticles();
    updateMotes(now);
    updatePulseRings();

    // Cinematic camera drift — slow orbital movement
    const camT = now * 0.00006;
    camera.position.x = Math.sin(camT) * 150;
    camera.position.z = 600 + Math.cos(camT * 0.7) * 100;
    camera.position.y = 750 + Math.sin(camT * 0.5) * 60;
    camera.lookAt(0, 0, -50);
  }

  // ══════════════════════════════════════════════════════════════════════
  //  RENDER LOOP
  // ══════════════════════════════════════════════════════════════════════
  function animate() {
    update(performance.now());
    composer.render();
    requestAnimationFrame(animate);
  }

  // ══════════════════════════════════════════════════════════════════════
  //  RESIZE + AMBIENT + START
  // ══════════════════════════════════════════════════════════════════════
  function onResize() {
    W = window.innerWidth; H = window.innerHeight;
    camera.aspect = W / H;
    camera.updateProjectionMatrix();
    renderer.setSize(W, H);
    composer.setSize(W, H);
    bloom.resolution.set(W, H);
  }
  window.addEventListener('resize', onResize);

  function ambientLoop() {
    if (cycles.filter(c => c.ambient).length < AMBIENT_MAX) {
      spawnCycle('', '', true);
    }
    setTimeout(ambientLoop, 3000 + Math.random() * 5000);
  }
  setTimeout(ambientLoop, 500);
  spawnCycle('', '', true);
  spawnCycle('', '', true);

  requestAnimationFrame(animate);

  // ── Expose Public API (replaces the stub from the non-module script) ──
  window.Grid = {
    spawnOrb(stepName, contestant) { spawnCycle(stepName, contestant, false); },
    derezzAll,
    emitPulse
  };

  console.log('%c\u26A1 [GRID] Three.js 3D Tron Arena — perspective cam, trail walls, bloom armed', 'color:#00f3ff;font-weight:bold');
})();
</script>
</body>
</html>
